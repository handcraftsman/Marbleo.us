// Generated by CoffeeScript 1.7.1

/** @const */

(function() {
  var ARRAY_EQUAL, Animator, BITLY_API_KEY, Block, Compressor, DEBUG, EventEmitter, Game, HitTestLayer, Layer, MAP_SIZE, Map, MapLayer, Marble, OVERLAY, POINT_DEBUG, Palette, Path, ROUGHLY, Renderer, SIGNUM, Settings, TEXTURE_SIZE, TextureStore, VECTOR_LENGTH, VisibilityLayer, defaultMaxListeners, isArray,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DEBUG = false;

  OVERLAY = false;

  POINT_DEBUG = true;

  MAP_SIZE = 17;

  TEXTURE_SIZE = 101;

  BITLY_API_KEY = "R_787e723dc060169b3bfde946beef129a";

  Settings = {
    mapSize: MAP_SIZE,
    mainCanvasID: '#main-canvas',
    draggedCanvasID: '#dragged-canvas',
    selectorID: '#selector',
    paletteID: '#palette',
    defaultCursor: 'auto',
    dragCursor: $.browser.webkit && '-webkit-grab' || $.browser.mozilla && '-moz-grab' || 'auto',
    draggingCursor: $.browser.webkit && '-webkit-grabbing' || $.browser.mozilla && '-moz-grabbing' || 'auto',
    draggingOffset: 10,
    textureSize: TEXTURE_SIZE,
    textureSizeHalf: Math.floor(TEXTURE_SIZE / 2),
    textureSizeQuarter: Math.floor(Math.floor(TEXTURE_SIZE / 2) / 2),
    canvasHeight: MAP_SIZE * TEXTURE_SIZE,
    canvasWidth: MAP_SIZE * TEXTURE_SIZE,
    textureFile: 'img/textures.png',
    gravity: 0.7,
    blockDampening: 0.3,
    groundDampening: 0.3,
    friction: 0.995,
    blockSize: 50
  };

  ROUGHLY = function(x, y, offset) {
    return Math.abs(x - y) < offset;
  };

  ARRAY_EQUAL = function(a, b) {
    var i;
    if (a.length !== b.length) {
      return false;
    }
    for (i in a) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };

  VECTOR_LENGTH = function(a, b, c) {
    return Math.sqrt(a * a + b * b + c * c);
  };

  SIGNUM = function(x) {
    if (x < 0) {
      return -1;
    } else if (x > 0) {
      return 1;
    } else {
      return 0;
    }
  };

  isArray = Array.isArray || function(o) {
    return Object.prototype.toString.call(o) === '[object Array]';
  };

  defaultMaxListeners = 10;

  EventEmitter = (function() {
    function EventEmitter() {}

    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!this.events) {
        this.events = {};
      }
      return this.events.maxListeners = n;
    };

    EventEmitter.prototype.getMaxListeners = function() {
      if (!this.events) {
        this.events = {};
      }
      return this.events.maxListeners;
    };

    EventEmitter.prototype.emit = function() {
      var handler, listener, parameters, type, _i, _len, _ref, _ref1;
      type = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (type === 'error') {
        if (!this.events || !this.events.error || isArray(this.events.error) && !this.events.error.length) {
          if (parameters[0] instanceof Error) {
            throw new parameters[0];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return false;
      }
      handler = (_ref = this.events) != null ? _ref[type] : void 0;
      if (!handler) {
        return false;
      }
      if (typeof handler === 'function') {
        switch (arguments.length) {
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, parameters[0]);
            break;
          case 3:
            handler.call(this, parameters[0], parameters[1]);
            break;
          default:
            handler.apply(this, parameters);
        }
        return true;
      } else if (isArray(handler)) {
        _ref1 = handler.slice();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          listener = _ref1[_i];
          listener.apply(this, parameters);
        }
        return true;
      } else {
        return false;
      }
    };

    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
      if (typeof listener !== 'function') {
        throw "addListener only takes instances of Function";
      }
      if (!this.events) {
        this.events = {};
      }
      this.emit('newListener', type, listener);
      if (!this.events[type]) {
        this.events[type] = listener;
      } else if (isArray(this.events[type])) {
        if (!this.events[type].warned) {
          if (this.events.maxListeners != null) {
            m = this.events.maxListeners;
          } else {
            m = defaultMaxListeners;
          }
        }
        if (m && m > 0 && this.events[type].length > m) {
          this.events[type].warned = true;
          if (DEBUG) {
            console.error("Possible EventEmitter memory leak detected.");
            console.trace();
          }
        }
        this.events[type].push(listener);
      } else {
        this.events[type] = [this.events[type], listener];
      }
      return this;
    };

    EventEmitter.prototype.once = function(type, listener) {
      var g;
      if (typeof listener !== 'function') {
        throw "once only takes instances of Function";
      }
      g = (function(_this) {
        return function() {
          _this.removeListener(type, g);
          return listener.apply(_this, arguments);
        };
      })(this);
      g.listener = listener;
      this.addListener(type, g);
      return this;
    };

    EventEmitter.prototype.removeListener = function(type, listener) {
      var i, list, position, _i, _ref, _ref1, _ref2;
      if (typeof listener !== 'function') {
        throw "removeListener only takes instances of Function";
      }
      if (!((_ref = this.events) != null ? _ref[type] : void 0)) {
        return this;
      }
      list = this.events[type];
      if (isArray(list)) {
        position = -1;
        for (i = _i = 0, _ref1 = list.length; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          if (list[i] === listener || ((_ref2 = list[i]) != null ? _ref2.listener : void 0) === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) {
          return this;
        }
        list.splice(position, 1);
        if (list.length === 0) {
          delete this.events[type];
        }
      } else if (list === listener || (list != null ? list.listener : void 0) === listener) {
        delete this.events[type];
      }
      return this;
    };

    EventEmitter.prototype.removeAllListeners = function(type) {
      var _ref;
      if (type && ((_ref = this.events) != null ? _ref[type] : void 0)) {
        this.events[type] = null;
      }
      return this;
    };

    EventEmitter.prototype.listeners = function(type) {
      if (!this.events) {
        this.events = {};
      }
      if (!this.events[type]) {
        this.events[type] = [];
      }
      if (!isArray(this.events[type])) {
        this.events[type] = [this.events[type]];
      }
      return this.events[type];
    };

    return EventEmitter;

  })();

  Block = (function(_super) {
    __extends(Block, _super);

    Block.canStack = function(bottom, top) {
      var midRotation, midType, topRotation, topType, _ref, _ref1;
      _ref = top.getProperty('middle'), midType = _ref[0], midRotation = _ref[1];
      _ref1 = bottom.getProperty('top'), topType = _ref1[0], topRotation = _ref1[1];
      if (topType) {
        if (midType === 'drop-low') {
          return false;
        }
        if (midType === 'dive' || midType === 'exchange' || midType === 'exchange-alt') {
          return false;
        }
      }
      return true;
    };

    Block.ofType = function(type, rotation) {
      if (rotation == null) {
        rotation = 0;
      }
      if (!Block.Types[type]) {
        throw new Error("Unknown type " + type);
      }
      return new Block(Block.Types[type], rotation);
    };

    function Block(description) {
      var key, value, _ref;
      this.properties = {
        'top': [null, 0],
        'middle': [null, 0],
        'low': [null, 0]
      };
      _ref = this.properties;
      for (key in _ref) {
        value = _ref[key];
        this.properties[key] = description[key] || value;
      }
      this.validate();
      this.setMaxListeners(1);
    }

    Block.prototype.setCoordinates = function(x, y, z) {
      if (x < 0 || y < 0 || z < 0) {
        throw new Error("Illegal coordinates " + x + ":" + y + ":" + z);
      }
      return this.coordinates = [x, y, z];
    };

    Block.prototype.getCoordinates = function() {
      return this.coordinates;
    };

    Block.prototype.validate = function(properties) {
      var level, lowRotation, lowType, midRotation, midType, rotation, topRotation, topType, type, _ref, _ref1, _ref2, _ref3, _ref4;
      if (properties == null) {
        properties = this.properties;
      }
      _ref = this.properties;
      for (level in _ref) {
        _ref1 = _ref[level], type = _ref1[0], rotation = _ref1[1];
        if (type && !(__indexOf.call(Block.Components[level], type) >= 0)) {
          throw new Error("Unknown " + level + " type " + type);
        }
        if (rotation !== 0 && rotation !== 90 && rotation !== 180 && rotation !== 270) {
          throw new Error("Rotation must be multiple of 90, was " + type);
        }
      }
      _ref2 = this.getProperty('top'), topType = _ref2[0], topRotation = _ref2[1];
      _ref3 = this.getProperty('middle'), midType = _ref3[0], midRotation = _ref3[1];
      _ref4 = this.getProperty('low'), lowType = _ref4[0], lowRotation = _ref4[1];
      if (topType === 'crossing-hole' && midType !== 'drop-middle' && midType !== 'drop-low') {
        throw new Error("Top type crossing with hole requires middle type drop, was " + midType);
      }
      if (topType !== 'crossing-hole' && (midType === 'drop-middle' || midType === 'drop-low')) {
        throw new Error("Middle type drop requires top type crossing with hole, was " + topType);
      }
      if (lowType && midType === 'drop-low') {
        throw new Error("Middle type " + midType + " is incompatible with low type " + lowType);
      }
    };

    Block.prototype.setOpacity = function(opacity, silent) {
      if (silent == null) {
        silent = false;
      }
      if (!((0 <= opacity && opacity <= 1.0))) {
        throw new Error("Illegal value for opacity");
      }
      this.opacity = opacity;
      if (!silent) {
        return this.emit('didChange');
      }
    };

    Block.prototype.setSelected = function(selected, silent) {
      this.selected = selected;
      if (silent == null) {
        silent = false;
      }
      if (!silent) {
        return this.emit('didChange');
      }
    };

    Block.prototype.setDragged = function(dragged) {
      this.dragged = dragged;
    };

    Block.prototype.getProperty = function(property) {
      if (property !== 'top' && property !== 'middle' && property !== 'low') {
        throw new Error("Unknown property " + property);
      }
      return this.properties[property];
    };

    Block.prototype.setProperty = function(property, type, rotation, silent) {
      var newProperties, oldRotation, oldType, _ref;
      if (silent == null) {
        silent = false;
      }
      _ref = this.getProperty(property), oldType = _ref[0], oldRotation = _ref[1];
      newProperties = {};
      if (rotation === null) {
        rotation = oldRotation;
      }
      newProperties[property] = [type, rotation];
      this.setProperties(newProperties, false);
      if (!silent) {
        return this.emit('didChange');
      }
    };

    Block.prototype.setProperties = function(properties, silent) {
      var key, newProperties, value, _ref, _ref1;
      newProperties = {};
      _ref = this.properties;
      for (key in _ref) {
        value = _ref[key];
        newProperties[key] = properties[key] || value;
      }
      this.validate(newProperties);
      _ref1 = this.properties;
      for (key in _ref1) {
        value = _ref1[key];
        this.properties[key] = properties[key] || value;
      }
      if (!silent) {
        return this.emit('didChange');
      }
    };

    Block.prototype.rotateCW = function() {
      return this.rotate(true);
    };

    Block.prototype.rotateCCW = function() {
      return this.rotate(false);
    };

    Block.prototype.rotate = function(clockwise, top, middle, low, silent) {
      var lowRotation, lowType, midRotation, midType, topRotation, topType, _ref, _ref1, _ref2;
      if (top == null) {
        top = true;
      }
      if (middle == null) {
        middle = true;
      }
      if (low == null) {
        low = true;
      }
      if (silent == null) {
        silent = false;
      }
      _ref = this.properties['top'], topType = _ref[0], topRotation = _ref[1];
      _ref1 = this.properties['middle'], midType = _ref1[0], midRotation = _ref1[1];
      _ref2 = this.properties['low'], lowType = _ref2[0], lowRotation = _ref2[1];
      if (clockwise) {
        this.setProperties({
          'top': top ? [topType, (topRotation + 90) % 360] : void 0,
          'middle': middle ? [midType, (midRotation + 90) % 360] : void 0,
          'low': low ? [lowType, (lowRotation + 90) % 360] : void 0
        }, true);
      } else {
        this.setProperties({
          'top': top ? [topType, (topRotation + 270) % 360] : void 0,
          'middle': middle ? [midType, (midRotation + 270) % 360] : void 0,
          'low': low ? [lowType, (lowRotation + 270) % 360] : void 0
        }, true);
      }
      if (!silent) {
        return this.emit('didChange');
      }
    };

    Block.prototype.toString = function() {
      var lowRotation, lowType, midRotation, midType, topRotation, topType, _ref, _ref1, _ref2;
      _ref = this.properties['top'], topType = _ref[0], topRotation = _ref[1];
      _ref1 = this.properties['middle'], midType = _ref1[0], midRotation = _ref1[1];
      _ref2 = this.properties['low'], lowType = _ref2[0], lowRotation = _ref2[1];
      return ("" + topType + topRotation) + ("" + midType + midRotation) + ("" + lowType + lowRotation) + ("" + this.opacity + this.selected);
    };

    Block.Components = {
      'top': ['crossing', 'crossing-hole', 'curve', 'straight'],
      'middle': ['crossing', 'curve', 'straight', 'dive', 'drop-middle', 'drop-low', 'exchange-alt', 'exchange'],
      'low': ['crossing', 'curve', 'straight']
    };

    Block.Types = {
      'blank': {},
      'crossing-hole': {
        'top': ['crossing-hole', 270],
        'middle': ['drop-middle', 0]
      },
      'crossing-hole-alt': {
        'top': ['crossing-hole', 270],
        'middle': ['drop-low', 0]
      },
      'double-straight': {
        'top': ['straight', 0],
        'middle': ['straight', 0]
      },
      'curve-straight': {
        'top': ['curve', 270],
        'middle': ['straight', 0]
      },
      'curve-straight-alt': {
        'top': ['curve', 180],
        'middle': ['straight', 0]
      },
      'double-curve': {
        'top': ['curve', 270],
        'middle': ['curve', 0]
      },
      'double-curve-alt': {
        'top': ['curve', 90],
        'middle': ['curve', 0]
      },
      'curve-exchange': {
        'top': ['curve', 270],
        'middle': ['exchange', 0]
      },
      'curve-exchange-alt': {
        'top': ['curve', 180],
        'middle': ['exchange-alt', 0]
      },
      'straight-exchange': {
        'top': ['straight', 0],
        'middle': ['exchange', 0]
      },
      'straight-exchange-alt': {
        'top': ['straight', 0],
        'middle': ['exchange-alt', 0]
      },
      'curve-dive': {
        'top': ['curve', 270],
        'middle': ['dive', 0]
      },
      'curve-dive-alt': {
        'top': ['curve', 0],
        'middle': ['dive', 0]
      },
      'crossing-straight': {
        'top': ['crossing', 270],
        'middle': ['straight', 0]
      }
    };

    return Block;

  })(EventEmitter);

  Path = (function() {
    var PathNode;

    Path.nodesForBlock = function(block) {
      var bX, bY, bZ, midNodes, midRotation, midType, nodesForDescription, rotateNodeCoordinates, topNodes, topRotation, topType, _ref, _ref1, _ref2;
      _ref = block.getCoordinates(), bX = _ref[0], bY = _ref[1], bZ = _ref[2];
      _ref1 = block.getProperty('top'), topType = _ref1[0], topRotation = _ref1[1];
      _ref2 = block.getProperty('middle'), midType = _ref2[0], midRotation = _ref2[1];
      rotateNodeCoordinates = function(rotation, x, y, z) {
        switch (rotation) {
          case 90:
            return [y, Settings.blockSize - x, z];
          case 180:
            return [Settings.blockSize - x, Settings.blockSize - y, z];
          case 270:
            return [Settings.blockSize - y, x, z];
          default:
            return [x, y, z];
        }
      };
      nodesForDescription = function(description, rotation) {
        var currentNodes, neighbourID, neighbours, node, nodeID, x, y, z, _i, _len, _ref3, _ref4, _ref5, _results;
        currentNodes = {};
        for (nodeID in description) {
          _ref3 = description[nodeID], x = _ref3[0], y = _ref3[1], z = _ref3[2], neighbours = 4 <= _ref3.length ? __slice.call(_ref3, 3) : [];
          x *= Settings.blockSize;
          y *= Settings.blockSize;
          z *= Settings.blockSize;
          _ref4 = rotateNodeCoordinates(rotation, x, y, z), x = _ref4[0], y = _ref4[1], z = _ref4[2];
          x += Settings.blockSize * bX;
          y += Settings.blockSize * bY;
          z += Settings.blockSize * bZ;
          currentNodes[nodeID] = new PathNode(x, y, z);
        }
        for (nodeID in description) {
          _ref5 = description[nodeID], x = _ref5[0], y = _ref5[1], z = _ref5[2], neighbours = 4 <= _ref5.length ? __slice.call(_ref5, 3) : [];
          node = currentNodes[nodeID];
          for (_i = 0, _len = neighbours.length; _i < _len; _i++) {
            neighbourID = neighbours[_i];
            node.addNeighbour(currentNodes[neighbourID]);
          }
        }
        _results = [];
        for (nodeID in currentNodes) {
          node = currentNodes[nodeID];
          _results.push(node);
        }
        return _results;
      };
      topNodes = nodesForDescription(Path.Descriptors.top[topType], topRotation);
      midNodes = nodesForDescription(Path.Descriptors.middle[midType], midRotation);
      return __slice.call(topNodes).concat(__slice.call(midNodes));
    };

    Path.nodesForMap = function(map) {
      var nodes;
      nodes = [];
      map.blocksEach((function(_this) {
        return function(block) {
          var node, _i, _len, _ref, _results;
          _ref = Path.nodesForBlock(block);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            _results.push(nodes.push(node));
          }
          return _results;
        };
      })(this));
      return nodes;
    };

    Path.forBlock = function(block) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Path, this.nodesForBlock(block), function(){});
    };

    Path.forMap = function(map) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Path, this.nodesForMap(map), function(){});
    };

    function Path() {
      var coordinates, key, node, nodes, _i, _len, _ref;
      nodes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.nodes = {};
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        key = node.toString();
        if (this.nodes[key] != null) {
          this.nodes[key] = PathNode.byJoining(this.nodes[key], node);
        } else {
          this.nodes[key] = node;
        }
      }
      this.nodeArray = [];
      _ref = this.nodes;
      for (coordinates in _ref) {
        node = _ref[coordinates];
        this.nodeArray.push(node);
      }
    }

    Path.prototype.getNodes = function() {
      return this.nodeArray;
    };

    Path.prototype.nodeAt = function(x, y, z) {
      return this.nodes["" + x + ":" + y + ":" + z] || null;
    };

    Path.prototype.rotate = function(clockwise) {
      var coordinates, node, rotatedNodes, _ref, _ref1, _results;
      rotatedNodes = {};
      ({
        rotateNode: function(node) {
          var x, y, z, _ref, _ref1, _ref2;
          _ref = node.getCoordinates(), x = _ref[0], y = _ref[1], z = _ref[2];
          if (clockwise) {
            _ref1 = [Settings.mapSize * Settings.blockSize - y, x], x = _ref1[0], y = _ref1[1];
          } else {
            _ref2 = [y, Settings.mapSize * Settings.blockSize - x], x = _ref2[0], y = _ref2[1];
          }
          return node.setCoordinates(x, y, z);
        }
      });
      _ref = this.nodes;
      for (coordinates in _ref) {
        node = _ref[coordinates];
        rotateNode(node);
        rotatedNodes[node.toString()] = node;
      }
      this.nodes = rotatedNodes;
      this.nodeArray = [];
      _ref1 = this.nodes;
      _results = [];
      for (coordinates in _ref1) {
        node = _ref1[coordinates];
        _results.push(this.nodeArray.push(node));
      }
      return _results;
    };

    PathNode = (function() {
      PathNode.byJoining = function(nodeA, nodeB) {
        var neighbourA, neighbourB, newNode;
        if (!ARRAY_EQUAL(nodeA.getCoordinates(), nodeB.getCoordinates())) {
          throw new Error("Node must be at same position.");
        }
        if (nodeA === nodeB) {
          throw new Error("Cannot join node with itself.");
        }
        if (nodeA.getNeighbours().length === 2 || nodeB.getNeighbours().length === 2) {
          throw new Error("Resulting node would have a degree bigger than 2.");
        }
        newNode = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(PathNode, nodeA.getCoordinates(), function(){});
        neighbourA = nodeA.getNeighbours()[0];
        neighbourB = nodeB.getNeighbours()[0];
        newNode.addNeighbour(neighbourA);
        newNode.addNeighbour(neighbourB);
        if (neighbourA != null ? neighbourA.removeNeighbour(nodeA) : void 0) {
          neighbourA.addNeighbour(newNode);
        }
        if (neighbourB != null ? neighbourB.removeNeighbour(nodeB) : void 0) {
          neighbourB.addNeighbour(newNode);
        }
        return newNode;
      };

      function PathNode(x, y, z) {
        this.coordinates = [x, y, z];
      }

      PathNode.prototype.setCoordinates = function(x, y, z) {
        return this.coordinates = [x, y, z];
      };

      PathNode.prototype.getCoordinates = function() {
        return this.coordinates;
      };

      PathNode.prototype.addNeighbour = function(node) {
        if (this.neighbour1 && this.neighbour2) {
          throw new Error("Maximum degree for a node is two");
        }
        if (this.neighbour1 == null) {
          this.neighbour1 = node;
        } else if (this.neighbour2 == null) {
          this.neighbour2 = node;
        }
        return this.getNeighbours();
      };

      PathNode.prototype.getNeighbours = function() {
        if (this.neighbour1 && this.neighbour2) {
          return [this.neighbour1, this.neighbour2];
        } else if (this.neighbour1) {
          return [this.neighbour1];
        } else if (this.neighbour2) {
          return [this.neighbour2];
        } else {
          return [];
        }
      };

      PathNode.prototype.removeNeighbour = function(node) {
        if (this.neighbour1 === node) {
          this.neighbour1 = null;
          return true;
        } else if (this.neighbour2 === node) {
          this.neighbour2 = null;
          return true;
        } else {
          return false;
        }
      };

      PathNode.prototype.toString = function() {
        var x, y, z, _ref;
        _ref = this.coordinates, x = _ref[0], y = _ref[1], z = _ref[2];
        return "" + x + ":" + y + ":" + z;
      };

      return PathNode;

    })();

    Path.Descriptors = {
      top: {
        'straight': {
          'a': [0, 1 / 2, 1, 'b'],
          'b': [1, 1 / 2, 1, 'a']
        },
        'crossing': {
          'a': [0, 1 / 2, 1, 'b'],
          'b': [1, 1 / 2, 1, 'a'],
          'c': [1 / 2, 0, 1, 'd'],
          'd': [1 / 2, 1, 1, 'c']
        },
        'curve': {
          'a': [0, 1 / 2, 1, 'b'],
          'b': [1 / 8, 4 / 8, 1, 'a', 'c'],
          'c': [3 / 8, 5 / 8, 1, 'b', 'd'],
          'd': [4 / 8, 7 / 8, 1, 'c', 'e'],
          'e': [1 / 2, 1, 1, 'd']
        }
      },
      middle: {
        'straight': {
          'a': [0, 1 / 2, 1 / 2, 'b'],
          'b': [1, 1 / 2, 1 / 2, 'a']
        },
        'crossing': {
          'a': [0, 1 / 2, 1 / 2, 'b'],
          'b': [1, 1 / 2, 1 / 2, 'a'],
          'c': [1 / 2, 0, 1 / 2, 'd'],
          'd': [1 / 2, 1, 1 / 2, 'c']
        },
        'curve': {
          'a': [0, 4 / 8, 1 / 2, 'b'],
          'b': [1 / 8, 4 / 8, 1 / 2, 'a', 'c'],
          'c': [3 / 8, 5 / 8, 1 / 2, 'b', 'd'],
          'd': [4 / 8, 7 / 8, 1 / 2, 'c', 'e'],
          'e': [4 / 8, 1, 1 / 2, 'd']
        },
        'dive': {
          'a': [0, 1 / 2, 4 / 8, 'b'],
          'b': [1, 1 / 2, 1 / 8, 'a']
        },
        'exchange': {
          'a': [0, 4 / 8, 4 / 8, 'b'],
          'b': [1 / 8, 4 / 8, 4 / 8, 'a', 'c'],
          'c': [3 / 8, 5 / 8, 2 / 8, 'b', 'd'],
          'd': [4 / 8, 7 / 8, 1 / 8, 'c', 'e'],
          'e': [4 / 8, 1, 1 / 8, 'd']
        },
        'exchange-alt': {
          'a': [0, 4 / 8, 1 / 8, 'b'],
          'b': [1 / 8, 4 / 8, 1 / 8, 'a', 'c'],
          'c': [3 / 8, 5 / 8, 2 / 8, 'b', 'd'],
          'd': [4 / 8, 7 / 8, 4 / 8, 'c', 'e'],
          'e': [4 / 8, 1, 4 / 8, 'd']
        },
        'drop-middle': {
          'a': [0, 1 / 2, 1, 'm'],
          'b': [1, 1 / 2, 1, 'm'],
          'c': [1 / 2, 0, 1, 'm'],
          'd': [1 / 2, 1, 1, 'm'],
          'm': [1 / 2, 1 / 2, 1, 'e'],
          'e': [1 / 2, 1 / 2, 6 / 8, 'm', 'f'],
          'f': [3 / 8, 1 / 2, 5 / 8, 'e', 'g'],
          'g': [1 / 8, 1 / 2, 4 / 8, 'f', 'h'],
          'h': [0, 1 / 2, 4 / 8, 'g']
        },
        'drop-low': {
          'a': [0, 1 / 2, 1, 'm'],
          'b': [1, 1 / 2, 1, 'm'],
          'c': [1 / 2, 0, 1, 'm'],
          'd': [1 / 2, 1, 1, 'm'],
          'm': [1 / 2, 1 / 2, 1, 'e'],
          'e': [1 / 2, 1 / 2, 4 / 8, 'm', 'f'],
          'f': [3 / 8, 1 / 2, 2 / 8, 'e', 'g'],
          'g': [1 / 8, 1 / 2, 1 / 8, 'f', 'h'],
          'h': [0, 1 / 2, 1 / 8, 'g']
        }
      }
    };

    return Path;

  })();

  Marble = (function() {
    function Marble(radius) {
      var _ref, _ref1;
      this.radius = radius != null ? radius : 7;
      _ref = [-5000, -5000, 0], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      _ref1 = [0, 0, 0], this.x_V = _ref1[0], this.y_V = _ref1[1], this.z_V = _ref1[2];
    }

    Marble.prototype.setCoordinates = function(x, y, z) {
      var _ref;
      if (!((x != null) && (y != null) && (z != null))) {
        throw new Error("Missing parameter");
      }
      return _ref = [x, y, z], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], _ref;
    };

    Marble.prototype.getCoordinates = function() {
      return [this.x, this.y, this.z];
    };

    Marble.prototype.setVelocities = function(x_V, y_V, z_V) {
      var _ref;
      if (!((x_V != null) && (y_V != null) && (z_V != null))) {
        throw new Error("Missing parameter");
      }
      return _ref = [x_V, y_V, z_V], this.x_V = _ref[0], this.y_V = _ref[1], this.z_V = _ref[2], _ref;
    };

    Marble.prototype.getVelocities = function() {
      return [this.x_V, this.y_V, this.z_V];
    };

    Marble.prototype.setTrackSpeed = function(trackSpeed) {
      if (trackSpeed == null) {
        throw new Error("Missing parameter");
      }
      if (isNaN(trackSpeed)) {
        throw new Error("Must not be NaN");
      }
      return this.trackSpeed = trackSpeed;
    };

    Marble.prototype.getTrackSpeed = function() {
      return this.trackSpeed;
    };

    Marble.prototype.setNeedsRedraw = function(needsRedraw) {
      this.needsRedraw = needsRedraw;
    };

    return Marble;

  })();

  Map = (function(_super) {
    __extends(Map, _super);

    function Map(size) {
      var map, x, _i, _ref;
      if (!((1 < size && size < 255))) {
        throw new Error("Size must be between 1 and 255");
      }

      /* @constant */
      this.size = size;
      this.setMaxListeners(2);

      /* @constant */
      this.grid = new Array(Math.pow(this.size, 3));
      for (x = _i = 0, _ref = Math.pow(this.size, 3); 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.grid[x] = null;
      }
      this.rotation = 0;
      map = this;
      this.blockDidChangeListener = function() {
        return map.emit('didChange');
      };
      this.emit('didChange');
    }

    Map.prototype.forceUpdate = function() {
      return this.emit('didChange');
    };

    Map.prototype.setBlock = function(block, x, y, z, silent) {
      var position, _ref, _ref1, _ref2;
      if (silent == null) {
        silent = false;
      }
      this.validateCoordinates(x, y, z);
      if (block) {
        block.setCoordinates(x, y, z);
      }
      if (this.rotation) {
        _ref = this.applyRotation(x, y), x = _ref[0], y = _ref[1];
      }
      position = x + y * this.size + z * this.size * this.size;
      if ((_ref1 = this.grid[position]) != null) {
        _ref1.removeListener('didChange', this.blockDidChangeListener);
      }
      this.grid[position] = block;
      if ((_ref2 = this.grid[position]) != null) {
        _ref2.addListener('didChange', this.blockDidChangeListener);
      }
      if (!silent) {
        return this.emit('didChange');
      }
    };

    Map.prototype.getBlock = function(x, y, z) {
      var _ref;
      this.validateCoordinates(x, y, z);
      if (this.rotation) {
        _ref = this.applyRotation(x, y), x = _ref[0], y = _ref[1];
      }
      return this.grid[x + y * this.size + z * this.size * this.size];
    };

    Map.prototype.removeBlock = function(x, y, z, silent) {
      var block;
      if (silent == null) {
        silent = false;
      }
      block = this.getBlock(x, y, z);
      this.setBlock(null, x, y, z, true);
      if (block != null) {
        block.removeListener('didChange', this.blockDidChangeListener);
      }
      if (block != null) {
        block.setCoordinates(null, null, null);
      }
      if (!silent) {
        this.emit('didChange');
      }
      return block;
    };

    Map.prototype.heightAt = function(x, y) {
      var height;
      this.validateCoordinates(x, y, 0);
      height = 0;
      while (height < this.size && this.getBlock(x, y, height)) {
        height++;
      }
      return height;
    };

    Map.prototype.getStack = function(x, y, z) {
      var blocks, currentZ, height, _i;
      if (z == null) {
        z = 0;
      }
      this.validateCoordinates(x, y, z);
      if (z > (height = this.heightAt(x, y))) {
        return [];
      }
      blocks = new Array;
      for (currentZ = _i = z; z <= height ? _i < height : _i > height; currentZ = z <= height ? ++_i : --_i) {
        blocks.push(this.getBlock(x, y, currentZ));
      }
      return blocks;
    };

    Map.prototype.setStack = function(blocks, x, y, z, silent) {
      var block, _i, _len;
      if (z == null) {
        z = 0;
      }
      if (silent == null) {
        silent = false;
      }
      this.validateCoordinates(x, y, z);
      if (!(blocks.length - 1 + z < this.size)) {
        throw new Error("Cannot place stack, height out of bounds");
      }
      for (_i = 0, _len = blocks.length; _i < _len; _i++) {
        block = blocks[_i];
        this.setBlock(block, x, y, z++, true);
      }
      if (!silent) {
        return this.emit('didChange');
      }
    };

    Map.prototype.removeStack = function(x, y, z, silent) {
      var currentZ, stack, _i, _ref;
      if (z == null) {
        z = 0;
      }
      if (silent == null) {
        silent = false;
      }
      stack = this.getStack(x, y, z);
      for (currentZ = _i = z, _ref = z + stack.length; z <= _ref ? _i < _ref : _i > _ref; currentZ = z <= _ref ? ++_i : --_i) {
        this.setBlock(null, x, y, z++, true);
      }
      if (!silent) {
        this.emit('didChange');
      }
      return stack;
    };

    Map.prototype.validate = function() {
      return this.blocksEach((function(_this) {
        return function(block) {
          var x, y, z, _ref;
          _ref = block.getCoordinates(), x = _ref[0], y = _ref[1], z = _ref[2];
          if (block && z > 0 && !_this.getBlock(x, y, z - 1)) {
            throw new Error("Encountered floating block at " + x + ":" + y + ":" + z);
          }
        };
      })(this));
    };

    Map.prototype.validateCoordinates = function(x, y, z) {
      if (!((0 <= x && x < this.size) && (0 <= y && y < this.size) && (0 <= z && z < this.size))) {
        throw new Error("Index out of bounds " + x + ":" + y + ":" + z);
      }
    };

    Map.prototype.applyRotation = function(x, y) {
      switch (this.rotation) {
        case 90:
          return [this.size - 1 - y, x];
        case 180:
          return [this.size - 1 - x, this.size - 1 - y];
        case 270:
          return [y, this.size - 1 - x];
        default:
          return [x, y];
      }
    };

    Map.prototype.blocksEach = function(functionToApply) {
      var block, x, y, z, _results;
      x = this.size - 1;
      _results = [];
      while (x + 1) {
        y = 0;
        while (y < this.size) {
          z = 0;
          while (z < this.size) {
            if (block = this.getBlock(x, y, z)) {
              functionToApply(block);
            }
            z++;
          }
          y++;
        }
        _results.push(x--);
      }
      return _results;
    };

    Map.prototype.coordinatesEach = function(functionToApply) {
      var x, y, z, _results;
      x = this.size - 1;
      _results = [];
      while (x + 1) {
        y = 0;
        while (y < this.size) {
          z = 0;
          while (z < this.size) {
            functionToApply(x, y, z);
            z++;
          }
          y++;
        }
        _results.push(x--);
      }
      return _results;
    };

    Map.prototype.rotateCW = function() {
      return this.rotate(true);
    };

    Map.prototype.rotateCCW = function() {
      return this.rotate(false);
    };

    Map.prototype.rotate = function(clockwise, silent) {
      var block, x, y, z, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (silent == null) {
        silent = false;
      }
      if (clockwise) {
        this.rotation = (this.rotation + 90) % 360;
      } else {
        this.rotation = (this.rotation + 270) % 360;
      }
      _ref = this.grid;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (block) {
          block.rotate(clockwise, true, true, true, true);
          _ref1 = block.getCoordinates(), x = _ref1[0], y = _ref1[1], z = _ref1[2];
          if (clockwise) {
            _ref2 = [y, this.size - 1 - x], x = _ref2[0], y = _ref2[1];
          } else {
            _ref3 = [this.size - 1 - y, x], x = _ref3[0], y = _ref3[1];
          }
          block.setCoordinates(x, y, z);
        }
      }
      if (!silent) {
        return this.emit('didRotate', clockwise);
      }
    };

    return Map;

  })(EventEmitter);

  TextureStore = (function() {
    function TextureStore(onload) {
      var onloadCallback, setupTextures, textureFile;
      this.textures = {};
      setupTextures = (function(_this) {
        return function(textureFile) {
          var canvas, context, error, rotation, rotationsCount, texture, textureDescription, textureGroup, textureOffset, textureSize, _ref, _results;
          textureOffset = 0;
          _ref = TextureStore.TextureFileDescription;
          _results = [];
          for (textureGroup in _ref) {
            textureDescription = _ref[textureGroup];
            _results.push((function() {
              var _base, _i, _results1;
              _results1 = [];
              for (texture in textureDescription) {
                rotationsCount = textureDescription[texture];
                if (DEBUG) {
                  console.log("loading " + textureGroup + "." + texture);
                }
                if ((_base = this.textures)[textureGroup] == null) {
                  _base[textureGroup] = {};
                }
                this.textures[textureGroup][texture] = new Array(rotationsCount);
                for (rotation = _i = 0; 0 <= rotationsCount ? _i < rotationsCount : _i > rotationsCount; rotation = 0 <= rotationsCount ? ++_i : --_i) {
                  canvas = document.createElement('canvas');
                  canvas.width = Settings.textureSize;
                  canvas.height = Settings.textureSize;
                  context = canvas.getContext('2d');
                  try {
                    textureSize = Settings.textureSize;
                    context.drawImage(textureFile, rotation * textureSize, textureOffset * textureSize, textureSize, textureSize, 0, 0, textureSize, textureSize);
                  } catch (_error) {
                    error = _error;
                    if (DEBUG) {
                      console.log("Encountered error " + error + " while loading texture: " + texture);
                      if (error.name === "INDEX_SIZE_ERR") {
                        console.log("Texture file may be too small");
                      }
                    }
                    break;
                  }
                  this.textures[textureGroup][texture][rotation] = canvas;
                }
                _results1.push(textureOffset++);
              }
              return _results1;
            }).call(_this));
          }
          return _results;
        };
      })(this);
      onloadCallback = (function(_this) {
        return function() {
          setupTextures(textureFile);
          return onload();
        };
      })(this);
      textureFile = new Image;
      textureFile.onload = onloadCallback;
      textureFile.src = Settings.textureFile;
    }

    TextureStore.prototype.getTexture = function(group, type, rotation) {
      var rotationCount;
      if (!rotation) {
        if (TextureStore.TextureFileDescription[group][type] != null) {
          return this.textures[group][type][0];
        }
      }
      rotationCount = TextureStore.TextureFileDescription[group][type];
      if (rotationCount == null) {
        return null;
      }
      return this.textures[group][type][rotation / 90 % rotationCount];
    };

    TextureStore.TextureFileDescription = {
      'basic': {
        'hitbox': 1,
        'floor-hitbox': 1,
        'solid': 1,
        'floor': 1,
        'backside': 1,
        'outline': 1,
        'hole-middle': 2,
        'hole-low': 2,
        'hole-bottom': 2
      },
      'cutouts-top': {
        'crossing': 1,
        'curve': 4,
        'straight': 2
      },
      'cutouts-bottom': {
        'crossing': 1,
        'curve': 4,
        'straight': 2
      },
      'top': {
        'crossing': 1,
        'crossing-hole': 1,
        'curve': 4,
        'straight': 2
      },
      'middle': {
        'crossing': 1,
        'curve': 4,
        'straight': 2,
        'dive': 4,
        'drop-middle': 4,
        'drop-low': 4,
        'exchange-alt': 4,
        'exchange': 4
      },
      'low': {
        'crossing': 1,
        'curve': 4,
        'straight': 2
      }
    };

    return TextureStore;

  })();

  Layer = (function() {
    function Layer(renderer, map) {
      this.renderer = renderer;
      this.map = map;
      this.canvas = document.createElement('canvas');
      this.canvas.width = Settings.canvasWidth;
      this.canvas.height = Settings.canvasHeight;
      this.context = this.canvas.getContext('2d');
      this.textureStore = this.renderer.getTextureStore();
    }

    Layer.prototype.getTexture = function(group, type, rotation) {
      return this.textureStore.getTexture(group, type, rotation);
    };

    Layer.prototype.getCanvas = function() {
      return this.canvas;
    };

    Layer.prototype.clear = function() {
      return this.context.clearRect(0, 0, Settings.canvasWidth, Settings.canvasHeight);
    };

    return Layer;

  })();

  HitTestLayer = (function(_super) {
    __extends(HitTestLayer, _super);

    function HitTestLayer(renderer, map) {
      this.renderer = renderer;
      this.map = map;
      HitTestLayer.__super__.constructor.apply(this, arguments);
      this.floor = this.getTexture('basic', 'floor-hitbox');
      this.hitbox = this.getTexture('basic', 'hitbox');
    }

    HitTestLayer.prototype.sideAtScreenCoordinates = function(x, y) {
      var pixel;
      pixel = this.context.getImageData(x, y, 1, 1);
      if (pixel.data[0] > 0) {
        return 'south';
      }
      if (pixel.data[1] > 0) {
        return 'east';
      }
      if (pixel.data[2] > 0) {
        return 'top';
      }
      if (pixel.data[3] > 0) {
        return 'floor';
      }
      return null;
    };

    HitTestLayer.prototype.redraw = function() {
      this.clear();
      return this.map.coordinatesEach((function(_this) {
        return function(x, y, z) {
          var block, screenX, screenY, _ref, _ref1;
          if (z === 0) {
            _ref = _this.renderer.floorCoordinates(x, y), screenX = _ref[0], screenY = _ref[1];
            _this.context.drawImage(_this.floor, screenX, screenY, Settings.textureSize, Settings.textureSize);
          }
          if ((block = _this.map.getBlock(x, y, z)) && !block.dragged) {
            _ref1 = _this.renderer.renderingCoordinatesForBlock(block), screenX = _ref1[0], screenY = _ref1[1];
            return _this.context.drawImage(_this.hitbox, screenX, screenY, Settings.textureSize, Settings.textureSize);
          }
        };
      })(this));
    };

    return HitTestLayer;

  })(Layer);

  Renderer = (function() {
    function Renderer(animator, map, marble, onload) {
      this.animator = animator;
      this.map = map;
      this.marble = marble;
      this.floorCoordinates = __bind(this.floorCoordinates, this);
      this.updateEverything = __bind(this.updateEverything, this);
      this.updateMarble = __bind(this.updateMarble, this);
      this.updateMap = __bind(this.updateMap, this);
      this.mainCanvas = $(Settings.mainCanvasID);
      this.mainCanvas.attr('width', Settings.canvasWidth);
      this.mainCanvas.attr('height', Settings.canvasHeight);
      this.mainContext = this.mainCanvas.get(0).getContext('2d');
      this.canvas = document.createElement('canvas');
      this.canvas.width = Settings.canvasWidth;
      this.canvas.height = Settings.canvasHeight;
      this.context = this.canvas.getContext('2d');
      this.marbleCanvas = document.createElement('canvas');
      this.marbleCanvas.width = Settings.canvasWidth;
      this.marbleCanvas.height = Settings.canvasHeight;
      this.marbleContext = this.marbleCanvas.getContext('2d');
      this.draggedCanvas = $(Settings.draggedCanvasID);
      this.draggedContext = this.draggedCanvas.get(0).getContext('2d');
      this.textureStore = new TextureStore((function(_this) {
        return function() {
          _this.hitTestLayer = new HitTestLayer(_this, _this.map);
          _this.mapLayer = new MapLayer(_this, _this.map);
          _this.visibilityLayer = new VisibilityLayer(_this, _this.map, _this.marble);
          _this.map.addListener('didChange', _this.updateMap);
          _this.map.addListener('didRotate', _this.updateEverything);
          _this.animator.addListener('marble:moved', _this.updateMarble);
          _this.updateEverything();
          return onload();
        };
      })(this));
    }

    Renderer.prototype.getTextureStore = function() {
      return this.textureStore;
    };

    Renderer.prototype.clear = function(context) {
      return context.clearRect(0, 0, Settings.canvasWidth, Settings.canvasHeight);
    };

    Renderer.prototype.updateMap = function() {
      if (DEBUG) {
        console.log("Redrawing map");
      }
      this.hitTestLayer.redraw();
      this.mapLayer.redraw();
      this.visibilityLayer.redraw();
      this.joinLayers();
      return this.updateMainCanvas();
    };

    Renderer.prototype.updateMarble = function() {
      var drawMarble;
      this.clear(this.marbleContext);
      this.visibilityLayer.redraw();
      drawMarble = (function(_this) {
        return function(context, marble) {
          var x, y, _ref;
          _ref = _this.renderingCoordinatesForMarble(marble), x = _ref[0], y = _ref[1];
          context.beginPath();
          context.arc(x, y, marble.radius, 0, Math.PI * 2, true);
          context.closePath();
          return context.fill();
        };
      })(this);
      this.marbleContext.globalCompositeOperation = 'source-over';
      drawMarble(this.marbleContext, this.marble);
      this.marbleContext.globalCompositeOperation = 'destination-out';
      this.marbleContext.globalAlpha = 0.4;
      this.marbleContext.drawImage(this.visibilityLayer.getCanvas(), 0, 0, Settings.canvasWidth, Settings.canvasHeight);
      this.marbleContext.globalAlpha = 1;
      return this.updateMainCanvas();
    };

    Renderer.prototype.updateEverything = function() {
      this.updateMap();
      return this.updateMarble();
    };

    Renderer.prototype.joinLayers = function() {
      var join;
      join = (function(_this) {
        return function(layer, alpha) {
          if (alpha == null) {
            alpha = 1.0;
          }
          _this.context.globalCompositeOperation = 'source-over';
          _this.context.globalAlpha = alpha;
          return _this.context.drawImage(layer.getCanvas(), 0, 0, Settings.canvasWidth, Settings.canvasHeight);
        };
      })(this);
      this.clear(this.context);
      join(this.mapLayer);
      if (OVERLAY) {
        return join(this.hitTestLayer, 0.4);
      }
    };

    Renderer.prototype.updateMainCanvas = function() {
      this.clear(this.mainContext);
      this.mainContext.drawImage(this.canvas, 0, 0, Settings.canvasWidth, Settings.canvasHeight);
      return this.mainContext.drawImage(this.marbleCanvas, 0, 0, Settings.canvasWidth, Settings.canvasHeight);
    };

    Renderer.prototype.drawBlock = function(context, block, x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      return this.mapLayer.drawBlock(context, block, x, y);
    };

    Renderer.prototype.drawDraggedBlocks = function(stack) {
      var block, height, index, width, _i, _len, _results;
      width = Settings.textureSize;
      height = stack.length === 1 ? Settings.textureSize : Settings.textureSize + Settings.textureSizeHalf * (stack.length - 1);
      this.draggedCanvas.attr('width', width);
      this.draggedCanvas.attr('height', height);
      _results = [];
      for (index = _i = 0, _len = stack.length; _i < _len; index = ++_i) {
        block = stack[index];
        _results.push(this.drawBlock(this.draggedContext, block, 0, height - Settings.textureSize - index * Settings.textureSizeHalf));
      }
      return _results;
    };

    Renderer.prototype.resolveScreenCoordinates = function(x, y) {
      var blockX, blockY, blockZ, currentBlock, pixel, screenX, screenY, side, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (!((0 < x && x < Settings.canvasWidth) && (0 < y && y < Settings.canvasHeight))) {
        return {};
      }
      side = this.sideAtScreenCoordinates(x, y);
      if (side === 'floor') {
        for (blockX = _i = 0, _ref = this.map.size; 0 <= _ref ? _i < _ref : _i > _ref; blockX = 0 <= _ref ? ++_i : --_i) {
          for (blockY = _j = _ref1 = this.map.size - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; blockY = _ref1 <= 0 ? ++_j : --_j) {
            _ref2 = this.floorCoordinates(blockX, blockY), screenX = _ref2[0], screenY = _ref2[1];
            if (!((screenX <= x && x < (screenX + Settings.textureSize)) && (screenY <= y && y < (screenY + Settings.textureSize)))) {
              continue;
            }
            pixel = this.textureStore.getTexture('basic', 'floor-hitbox').getContext('2d').getImageData(x - screenX, y - screenY, 1, 1);
            if (pixel.data[3] > 0) {
              return {
                coordinates: [blockX, blockY, 0],
                side: 'floor'
              };
            }
          }
        }
      } else if (side) {
        for (blockX = _k = 0, _ref3 = this.map.size; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; blockX = 0 <= _ref3 ? ++_k : --_k) {
          for (blockY = _l = _ref4 = this.map.size - 1; _ref4 <= 0 ? _l <= 0 : _l >= 0; blockY = _ref4 <= 0 ? ++_l : --_l) {
            for (blockZ = _m = _ref5 = this.map.size - 1; _ref5 <= 0 ? _m <= 0 : _m >= 0; blockZ = _ref5 <= 0 ? ++_m : --_m) {
              currentBlock = this.map.getBlock(blockX, blockY, blockZ);
              if (!currentBlock || currentBlock.dragged) {
                continue;
              }
              _ref6 = this.renderingCoordinatesForBlock(currentBlock), screenX = _ref6[0], screenY = _ref6[1];
              if (!((screenX <= x && x < (screenX + Settings.textureSize)) && (screenY <= y && y < (screenY + Settings.textureSize)))) {
                continue;
              }
              pixel = this.textureStore.getTexture('basic', 'hitbox').getContext('2d').getImageData(x - screenX, y - screenY, 1, 1);
              if (pixel.data[3] > 0) {
                return {
                  block: currentBlock,
                  coordinates: [blockX, blockY, blockZ],
                  side: side
                };
              }
            }
          }
        }
      } else {
        return {};
      }
    };

    Renderer.prototype.sideAtScreenCoordinates = function(x, y) {
      return this.hitTestLayer.sideAtScreenCoordinates(x, y);
    };

    Renderer.prototype.renderingCoordinatesForMarble = function(marble) {
      var screenX, screenY, x, y, z, _ref;
      _ref = marble.getCoordinates(), x = _ref[0], y = _ref[1], z = _ref[2];
      screenX = x + y;
      screenY = Settings.canvasHeight - 7 * Settings.textureSizeQuarter - (2 * z + x - y) / 2;
      return [screenX, screenY];
    };

    Renderer.prototype.renderingCoordinatesForBlock = function(block) {
      var screenX, screenY, x, y, z, _ref;
      _ref = block.getCoordinates(), x = _ref[0], y = _ref[1], z = _ref[2];
      screenX = (x + y) * Settings.textureSizeHalf;
      screenY = Settings.canvasHeight - 3 * Settings.textureSizeQuarter - (2 * z + x - y + this.map.size) * Settings.textureSizeQuarter;
      return [screenX, screenY];
    };

    Renderer.prototype.floorCoordinates = function(x, y) {
      var screenX, screenY;
      screenX = (x + y) * Settings.textureSizeHalf;
      screenY = Settings.canvasHeight - 3 * Settings.textureSizeQuarter - (x - y + this.map.size) * Settings.textureSizeQuarter;
      return [screenX, screenY];
    };

    return Renderer;

  })();

  MapLayer = (function(_super) {
    __extends(MapLayer, _super);

    function MapLayer(renderer, map) {
      this.renderer = renderer;
      this.map = map;
      MapLayer.__super__.constructor.apply(this, arguments);
      this.cache = {};
    }

    MapLayer.prototype.redraw = function() {
      this.clear();
      this.drawFloor();
      return this.map.coordinatesEach((function(_this) {
        return function(bX, bY, bZ) {
          var block;
          if (block = _this.map.getBlock(bX, bY, bZ)) {
            return _this.drawBlock(_this.context, block);
          }
        };
      })(this));
    };

    MapLayer.prototype.drawFloor = function() {
      var screenX, screenY, x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = this.map.size; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _ref2, _results1;
          _results1 = [];
          for (y = _j = 0, _ref1 = this.map.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            _ref2 = this.renderer.floorCoordinates(x, y), screenX = _ref2[0], screenY = _ref2[1];
            _results1.push(this.context.drawImage(this.getTexture('basic', 'floor'), screenX, screenY, Settings.textureSize, Settings.textureSize));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    MapLayer.prototype.drawBlock = function(context, block, x, y) {
      var backside, bottomHoleEast, bottomHoleSouth, bottomHoles, buffer, cache_key, cached, cutouts, lowHoleEast, lowHoleSouth, lowHoles, lowRotation, lowType, low_texture, midHoleEast, midHoleSouth, midHoles, midRotation, midType, mid_texture, pos, solid, topRotation, topType, top_texture, type, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (!((x != null) && (y != null))) {
        _ref = this.renderer.renderingCoordinatesForBlock(block), x = _ref[0], y = _ref[1];
      }
      cache_key = block.toString();
      if (!(cached = this.cache[cache_key])) {
        _ref1 = block.getProperty('top'), topType = _ref1[0], topRotation = _ref1[1];
        _ref2 = block.getProperty('middle'), midType = _ref2[0], midRotation = _ref2[1];
        _ref3 = block.getProperty('low'), lowType = _ref3[0], lowRotation = _ref3[1];
        this.cache[cache_key] = cached = document.createElement('canvas');
        cached.height = cached.width = Settings.textureSize;
        buffer = cached.getContext("2d");
        if (block.selected || block.opacity !== 1.0) {
          backside = this.getTexture('basic', 'backside');
          buffer.drawImage(backside, 0, 0);
          if (lowType) {
            low_texture = this.getTexture('low', lowType, lowRotation);
            if (low_texture != null) {
              buffer.drawImage(low_texture, 0, 0);
            }
          }
          if (midType) {
            mid_texture = this.getTexture('middle', midType, midRotation);
            if (mid_texture != null) {
              buffer.drawImage(mid_texture, 0, 0);
            }
          }
        }
        if (block.selected) {
          buffer.globalAlpha = 0.3;
        } else {
          buffer.globalAlpha = block.opacity || 1.0;
        }
        solid = this.getTexture('basic', 'solid');
        buffer.drawImage(solid, 0, 0);
        buffer.globalAlpha = 1.0;
        if (topType) {
          top_texture = this.getTexture('top', topType, topRotation);
          if (top_texture != null) {
            if (block.selected) {
              buffer.globalAlpha = 0.6;
            }
            buffer.drawImage(top_texture, 0, 0);
            buffer.globalAlpha = 1.0;
          }
        }
        midHoles = MapLayer.MidHoles[midType];
        if (midHoles) {
          for (_i = 0, _len = midHoles.length; _i < _len; _i++) {
            pos = midHoles[_i];
            if ((pos + midRotation) % 360 === 0) {
              midHoleSouth = this.getTexture('basic', 'hole-middle', 0);
              buffer.drawImage(midHoleSouth, 0, 0);
            }
            if ((pos + midRotation) % 360 === 90) {
              midHoleEast = this.getTexture('basic', 'hole-middle', 90);
              buffer.drawImage(midHoleEast, 0, 0);
            }
          }
        }
        lowHoles = MapLayer.LowHoles[midType];
        if (lowHoles) {
          for (_j = 0, _len1 = lowHoles.length; _j < _len1; _j++) {
            pos = lowHoles[_j];
            if ((pos + midRotation) % 360 === 0) {
              lowHoleSouth = this.getTexture('basic', 'hole-low', 0);
              buffer.drawImage(lowHoleSouth, 0, 0);
            }
            if ((pos + midRotation) % 360 === 90) {
              lowHoleEast = this.getTexture('basic', 'hole-low', 90);
              buffer.drawImage(lowHoleEast, 0, 0);
            }
          }
        }
        bottomHoles = MapLayer.BottomHoles[lowType];
        if (bottomHoles) {
          for (_k = 0, _len2 = bottomHoles.length; _k < _len2; _k++) {
            pos = bottomHoles[_k];
            if ((pos + lowRotation) % 360 === 0) {
              bottomHoleSouth = this.getTexture('basic', 'hole-bottom', 0);
              buffer.drawImage(bottomHoleSouth, 0, 0);
            }
            if ((pos + lowRotation) % 360 === 90) {
              bottomHoleEast = this.getTexture('basic', 'hole-bottom', 90);
              buffer.drawImage(bottomHoleEast, 0, 0);
            }
          }
        }
        this.drawOutline(buffer, 0, 0);
        type = topType === 'crossing-hole' ? 'crossing' : topType;
        cutouts = this.getTexture('cutouts-top', type, topRotation);
        if (cutouts) {
          buffer.globalCompositeOperation = 'destination-out';
          buffer.drawImage(cutouts, 0, 0);
          buffer.globalCompositeOperation = 'source-over';
        }
        cutouts = this.getTexture('cutouts-bottom', lowType, lowRotation);
        if (cutouts) {
          buffer.globalCompositeOperation = 'destination-out';
          buffer.drawImage(cutouts, 0, 0);
          buffer.globalCompositeOperation = 'source-over';
        }
      }
      return context.drawImage(cached, x, y);
    };

    MapLayer.prototype.drawOutline = function(context, x, y) {
      return context.drawImage(this.getTexture('basic', 'outline'), x, y);
    };

    MapLayer.Cutouts = {
      'straight': [0, 180],
      'curve': [0, 90],
      'crossing': [0, 90, 180, 270]
    };

    MapLayer.MidHoles = {
      'crossing': [0, 90, 180, 270],
      'curve': [0, 90],
      'straight': [0, 180],
      'dive': [0],
      'drop-middle': [0],
      'exchange': [0],
      'exchange-alt': [90]
    };

    MapLayer.LowHoles = {
      'dive': [180],
      'drop-low': [0],
      'exchange': [90],
      'exchange-alt': [0]
    };

    MapLayer.BottomHoles = {
      'straight': [0, 180],
      'curve': [0, 90],
      'crossing': [0, 90, 180, 270]
    };

    return MapLayer;

  })(Layer);

  Animator = (function(_super) {
    __extends(Animator, _super);

    function Animator(map, marble) {
      this.map = map;
      this.marble = marble;
      this.handleRotation = __bind(this.handleRotation, this);
      this.updatePath = __bind(this.updatePath, this);
      this.map.addListener('didChange', this.updatePath);
      this.map.addListener('didRotate', this.handleRotation);
      this.updatePath();
    }

    Animator.prototype.updatePath = function() {
      var newLastNode, newTargetNode, _ref, _ref1;
      this.path = Path.forMap(this.map);
      if (this.marble.isOnTrack) {
        newTargetNode = (_ref = this.path).nodeAt.apply(_ref, this.marble.targetNode.getCoordinates());
        newLastNode = (_ref1 = this.path).nodeAt.apply(_ref1, this.marble.lastNode.getCoordinates());
      }
      if (newTargetNode && newLastNode && this.marble.currentBlock === this.blockAtWorldCoordinates.apply(this, this.marble.getCoordinates())) {
        this.marble.targetNode = newTargetNode;
        return this.marble.lastNode = newLastNode;
      } else {
        this.marble.isOnTrack = false;
        this.marble.targetNode = null;
        return this.marble.lastNode = null;
      }
    };

    Animator.prototype.handleRotation = function(clockwise) {
      var newLastNode, newTargetNode, rotateCoordinates, vX, vY, vZ, x, y, z, _ref, _ref1, _ref2, _ref3, _ref4;
      rotateCoordinates = function(x, y, z) {
        if (clockwise) {
          return [y, Settings.blockSize * Settings.mapSize - x, z];
        } else {
          return [Settings.blockSize * Settings.mapSize - y, x, z];
        }
      };
      _ref = this.marble.getCoordinates(), x = _ref[0], y = _ref[1], z = _ref[2];
      (_ref1 = this.marble).setCoordinates.apply(_ref1, rotateCoordinates(x, y, z));
      this.path = Path.forMap(this.map);
      if (this.marble.isOnTrack) {
        newTargetNode = (_ref2 = this.path).nodeAt.apply(_ref2, rotateCoordinates.apply(null, this.marble.targetNode.getCoordinates()));
        newLastNode = (_ref3 = this.path).nodeAt.apply(_ref3, rotateCoordinates.apply(null, this.marble.lastNode.getCoordinates()));
        if (newTargetNode && newLastNode) {
          this.marble.targetNode = newTargetNode;
          return this.marble.lastNode = newLastNode;
        } else {
          this.marble.isOnTrack = false;
          this.marble.targetNode = null;
          return this.marble.lastNode = null;
        }
      } else {
        _ref4 = this.marble.getVelocities(), vX = _ref4[0], vY = _ref4[1], vZ = _ref4[2];
        if (clockwise) {
          return this.marble.setVelocities(vY, -vX, vZ);
        } else {
          return this.marble.setVelocities(-vY, vX, vZ);
        }
      }
    };

    Animator.prototype.blockAtWorldCoordinates = function(x, y, z) {
      var bX, bY, bZ;
      bX = Math.floor(x / (Settings.blockSize + 1));
      bY = Math.floor(y / (Settings.blockSize + 1));
      bZ = Math.floor(z / (Settings.blockSize + 1));
      if ((0 <= bX && bX < this.map.size) && (0 <= bY && bY < this.map.size) && (0 <= bZ && bZ < this.map.size)) {
        return this.map.getBlock(bX, bY, bZ);
      } else {
        return null;
      }
    };

    Animator.prototype.applyFriction = function(velocity) {
      if (ROUGHLY(velocity, 0, 0.09)) {
        return 0;
      } else {
        return velocity * Settings.friction;
      }
    };

    Animator.prototype.animate = function() {
      var a, bX, bY, bZ, block, dX, dXY, dY, dZ, distance, lX, lY, lZ, mX, mY, mZ, nX, nY, nZ, neighbour, newSpeed, new_vX, new_vY, new_vZ, next, nextBlock, oldSpeed, old_mX, old_mY, old_mZ, r, s, slope, tX, tY, tZ, trackTest, vX, vY, vZ, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      _ref = this.marble.getCoordinates(), mX = _ref[0], mY = _ref[1], mZ = _ref[2];
      _ref1 = this.marble.getVelocities(), vX = _ref1[0], vY = _ref1[1], vZ = _ref1[2];
      r = this.marble.radius;
      _ref2 = [mX, mY, mZ], old_mX = _ref2[0], old_mY = _ref2[1], old_mZ = _ref2[2];
      trackTest = function(x3, y3, z3, nodeA, nodeB) {
        var isInfinite, linearEquationXY, linearEquationXZ, linearEquationYZ, slope, slopeXY, slopeXZ, slopeYZ, x, x1, x2, xy, xz, y, y1, y2, yz, z, z1, z2, _ref3, _ref4;
        _ref3 = nodeA.getCoordinates(), x2 = _ref3[0], y2 = _ref3[1], z2 = _ref3[2];
        _ref4 = nodeB.getCoordinates(), x1 = _ref4[0], y1 = _ref4[1], z1 = _ref4[2];
        slope = function(x1, x2, y1, y2) {
          return (y1 - y2) / (x1 - x2) || 0;
        };
        isInfinite = function(x) {
          return !isFinite(x);
        };
        slopeXY = slope(x1, x2, y1, y2);
        linearEquationXY = function(marbleX) {
          return slopeXY * marbleX + y1 - slopeXY * x1;
        };
        slopeXZ = slope(x1, x2, z1, z2);
        linearEquationXZ = function(marbleX) {
          return slopeXZ * marbleX + z1 - slopeXZ * x1;
        };
        slopeYZ = slope(y1, y2, z1, z2);
        linearEquationYZ = function(marbleY) {
          return slopeYZ * marbleY + z1 - slopeYZ * y1;
        };
        xy = isInfinite(slopeXY) ? ROUGHLY(x1, x3, 3) : ROUGHLY(y3, linearEquationXY(x3), 4);
        xz = isInfinite(slopeXZ) ? ROUGHLY(x1, x3, 3) : ROUGHLY(z3, linearEquationXZ(x3), 3);
        yz = isInfinite(slopeYZ) ? ROUGHLY(y1, y3, 6) : ROUGHLY(z3, linearEquationYZ(y3), 6);
        if (xy && xz && yz) {
          x = isInfinite(slopeXY) ? x1 : x3;
          y = isInfinite(slopeXY) ? y3 : linearEquationXY(x);
          z = isInfinite(slopeXZ) ? z3 : linearEquationXZ(x);
          if ((Math.min(x1, x2) - 3 <= x && x <= Math.max(x1, x2) + 3) && (Math.min(y1, y2) - 3 <= y && y <= Math.max(y1, y2) + 3) && (Math.min(z1, z2) - 8 <= z && z <= Math.max(z1, z2) + 2)) {
            return [x, y, z];
          } else {
            return null;
          }
        } else {
          return null;
        }
      };
      if (!this.marble.isOnTrack) {
        block = this.blockAtWorldCoordinates(mX, mY, mZ - r - 1);
        if ((block != null) && (vZ <= 0 || block !== this.marble.currentBlock && vZ >= 0)) {
          (function(_this) {
            return (function() {
              var hitNode, nX, nY, nZ, neighbour, node, pX, pY, pZ, topRotation, topType, _i, _j, _len, _len1, _ref10, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
              _ref3 = Path.nodesForBlock(block);
              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                node = _ref3[_i];
                _ref4 = node.getNeighbours();
                for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                  neighbour = _ref4[_j];
                  if (hitNode = trackTest(mX, mY, mZ - r - 1, node, neighbour)) {
                    mX = hitNode[0], mY = hitNode[1], mZ = hitNode[2];
                    _ref5 = node.getCoordinates(), pX = _ref5[0], pY = _ref5[1], pZ = _ref5[2];
                    _ref6 = neighbour.getCoordinates(), nX = _ref6[0], nY = _ref6[1], nZ = _ref6[2];
                    if (SIGNUM(pX - nX) !== 0 && SIGNUM(pX - nX) === SIGNUM(vX) || SIGNUM(pY - nY) !== 0 && SIGNUM(pY - nY) === SIGNUM(vY) || SIGNUM(pZ - nZ) !== 0 && SIGNUM(pZ - nZ) === SIGNUM(vZ)) {
                      _ref7 = [neighbour, node], node = _ref7[0], neighbour = _ref7[1];
                    }
                    _ref8 = block.getProperty('top'), topType = _ref8[0], topRotation = _ref8[1];
                    if (topType !== 'crossing-hole') {
                      vX = vX * SIGNUM(pX - nX);
                      vY = vY * SIGNUM(pY - nY);
                      vZ = vZ * SIGNUM(pZ - nZ);
                    }
                    _this.marble.setTrackSpeed(VECTOR_LENGTH(vX, vY, vZ));
                    _this.marble.currentBlock = block;
                    _this.marble.targetNode = (_ref9 = _this.path).nodeAt.apply(_ref9, neighbour.getCoordinates());
                    _this.marble.lastNode = (_ref10 = _this.path).nodeAt.apply(_ref10, node.getCoordinates());
                    _this.marble.isOnTrack = true;
                    return;
                  }
                }
              }
              return _this.marble.isOnTrack = false;
            });
          })(this)();
        }
      }
      if (this.marble.isOnTrack) {
        this.marble.currentBlock = this.blockAtWorldCoordinates(mX, mY, mZ) || this.marble.currentBlock;
        _ref3 = this.marble.targetNode.getCoordinates(), tX = _ref3[0], tY = _ref3[1], tZ = _ref3[2];
        _ref4 = this.marble.lastNode.getCoordinates(), lX = _ref4[0], lY = _ref4[1], lZ = _ref4[2];
        dX = tX - mX;
        dY = tY - mY;
        dZ = tZ - mZ;
        distance = VECTOR_LENGTH(dX, dY, dZ);
        if (distance < this.marble.radius && this.marble.targetNode.getNeighbours().length === 1 && this.marble.targetNode.getNeighbours()[0] === this.marble.lastNode) {
          _ref5 = this.marble.currentBlock.getCoordinates(), bX = _ref5[0], bY = _ref5[1], bZ = _ref5[2];
          nX = bX + SIGNUM(tX - lX);
          nY = bY + SIGNUM(tY - lY);
          nZ = bZ + SIGNUM(tZ - lZ);
          if ((0 <= nX && nX < this.map.size) && (0 <= nY && nY < this.map.size) && (0 <= nZ && nZ < this.map.size)) {
            nextBlock = this.map.getBlock(nX, nY, nZ);
          }
          if (nextBlock) {
            _ref6 = [this.marble.lastNode, this.marble.targetNode], this.marble.targetNode = _ref6[0], this.marble.lastNode = _ref6[1];
            this.marble.setTrackSpeed(this.marble.getTrackSpeed() * Settings.blockDampening);
            _ref7 = this.marble.targetNode.getCoordinates(), tX = _ref7[0], tY = _ref7[1], tZ = _ref7[2];
            _ref8 = this.marble.lastNode.getCoordinates(), lX = _ref8[0], lY = _ref8[1], lZ = _ref8[2];
            dX = tX - mX;
            dY = tY - mY;
            dZ = tZ - mZ;
            distance = VECTOR_LENGTH(dX, dY, dZ);
          }
        }
        dXY = Math.sqrt(dX * dX + dY * dY);
        slope = !(isNaN(dZ / dXY)) ? dZ / dXY : Infinity;
        a = Math.atan(slope) / (Math.PI / 2);
        oldSpeed = this.marble.getTrackSpeed();
        this.marble.setTrackSpeed(this.marble.getTrackSpeed() - Settings.gravity * a);
        this.marble.setTrackSpeed(this.applyFriction(this.marble.getTrackSpeed()));
        newSpeed = this.marble.getTrackSpeed();
        if (((tZ > mZ && mZ > lZ)) && SIGNUM(dZ / newSpeed) === -1 || ((tZ < mZ && mZ < lZ)) && SIGNUM(dZ / newSpeed) === 1) {
          _ref9 = [this.marble.lastNode, this.marble.targetNode], this.marble.targetNode = _ref9[0], this.marble.lastNode = _ref9[1];
          _ref10 = this.marble.targetNode.getCoordinates(), tX = _ref10[0], tY = _ref10[1], tZ = _ref10[2];
          _ref11 = this.marble.lastNode.getCoordinates(), lX = _ref11[0], lY = _ref11[1], lZ = _ref11[2];
          dX = tX - mX;
          dY = tY - mY;
          dZ = tZ - mZ;
        } else if (mZ < tZ && SIGNUM(dZ / newSpeed) === -1) {
          this.marble.setTrackSpeed(0);
          mZ = lZ;
        }
        if (distance > this.marble.getTrackSpeed()) {
          s = distance / this.marble.getTrackSpeed();
          mX += dX / s;
          mY += dY / s;
          mZ += dZ / s;
        } else {
          _ref12 = [tX, tY, tZ], mX = _ref12[0], mY = _ref12[1], mZ = _ref12[2];
          _ref13 = this.marble.targetNode.getNeighbours();
          for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
            neighbour = _ref13[_i];
            if (neighbour !== this.marble.lastNode) {
              next = neighbour;
            }
          }
          if (next) {
            this.marble.lastNode = this.marble.targetNode;
            this.marble.targetNode = next;
          } else {
            dX = tX - lX;
            dY = tY - lY;
            dZ = tZ - lZ;
            s = VECTOR_LENGTH(dX, dY, dZ) / this.marble.getTrackSpeed();
            new_vX = dX / s;
            new_vY = dY / s;
            new_vZ = dZ / s;
            this.marble.isOnTrack = false;
            _ref14 = [new_vX, new_vY, new_vZ], vX = _ref14[0], vY = _ref14[1], vZ = _ref14[2];
            this.marble.targetNode = null;
            this.marble.lastNode = null;
          }
        }
      }
      if (!this.marble.isOnTrack) {
        mX += vX;
        mY += vY;
        mZ += vZ;
        vZ -= Settings.gravity;
        this.map.blocksEach((function(_this) {
          return function(block) {
            var blockHighX, blockHighY, blockLowX, blockLowY, blockMidX, blockMidY, cX, cY, cZ, hit, xMatch, yMatch, zMatch, _ref15, _ref16;
            if (block === _this.marble.currentBlock) {
              return;
            }
            _ref15 = block.getCoordinates(), bX = _ref15[0], bY = _ref15[1], bZ = _ref15[2];
            if (_this.marble.currentBlock) {
              _ref16 = _this.marble.currentBlock.getCoordinates(), cX = _ref16[0], cY = _ref16[1], cZ = _ref16[2];
              if (bX === cX && bY === cY && bZ === cZ + 1) {
                return;
              }
            }
            xMatch = mX >= bX * Settings.blockSize && mX < (bX + 1) * Settings.blockSize;
            yMatch = mY >= bY * Settings.blockSize && mY < (bY + 1) * Settings.blockSize;
            zMatch = mZ >= bZ * Settings.blockSize && mZ < (bZ + 1) * Settings.blockSize;
            if (xMatch && yMatch) {
              if (mZ - r < (bZ + 1) * Settings.blockSize) {
                mZ = Math.round(mZ / Settings.blockSize) * Settings.blockSize + r;
                vZ = -vZ * Settings.blockDampening;
                if (Math.abs(vZ) < 0.5) {
                  vZ = 0;
                }
                hit = true;
              }
            }
            if (xMatch && zMatch) {
              blockLowY = bY * Settings.blockSize;
              blockMidY = bY * Settings.blockSize + Settings.blockSize / 2;
              blockHighY = (bY + 1) * Settings.blockSize;
              if (mY + r > blockLowY && mY - r < blockHighY) {
                vY = -vY * Settings.blockDampening;
                if (mY <= blockMidY) {
                  mY = Math.round(mY / Settings.blockSize) * Settings.blockSize - r;
                } else {
                  mY = Math.round(mY / Settings.blockSize) * Settings.blockSize + r;
                }
                hit = true;
              }
            }
            if (yMatch && zMatch) {
              blockLowX = bX * Settings.blockSize;
              blockMidX = bX * Settings.blockSize + Settings.blockSize / 2;
              blockHighX = (bX + 1) * Settings.blockSize;
              if (mX + r > blockLowX && mX - r < blockHighX) {
                vX = -vX * Settings.blockDampening;
                if (mX <= blockMidX) {
                  mX = Math.round(mX / Settings.blockSize) * Settings.blockSize - r;
                } else {
                  mX = Math.round(mX / Settings.blockSize) * Settings.blockSize + r;
                }
                hit = true;
              }
            }
            if (hit) {
              return _this.marble.currentBlock = null;
            }
          };
        })(this));
        if (mZ - this.marble.radius < 0) {
          mZ = this.marble.radius;
          vZ = -vZ * 0.3;
          if (Math.abs(vZ) < 0.5) {
            vZ = 0;
          }
          this.marble.currentBlock = null;
        }
        if (mZ === old_mZ) {
          vX = this.applyFriction(vX);
          vY = this.applyFriction(vY);
        }
      }
      this.marble.setCoordinates(mX, mY, mZ);
      this.marble.setVelocities(vX, vY, vZ);
      if (old_mZ !== mZ || old_mY !== mY || old_mX !== mX) {
        return this.emit('marble:moved');
      }
    };

    return Animator;

  })(EventEmitter);

  Compressor = (function() {
    Compressor.BytesPerBlock = 4;

    function Compressor() {}

    Compressor.prototype.compress = function(map) {
      var block, bytes, currentByte, gapSize, x, y, z, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3;
      bytes = new Array;
      gapSize = 0;
      for (x = _i = 0, _ref = map.size; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = map.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          for (z = _k = 0, _ref2 = map.size; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
            if (!(block = map.getBlock(x, y, z))) {
              gapSize++;
              continue;
            }
            if (gapSize > 0) {
              bytes.push(0xFF);
              bytes.push((gapSize & 0xFF0000) >> 16);
              bytes.push((gapSize & 0x00FF00) >> 8);
              bytes.push(gapSize & 0x0000FF);
              gapSize = 0;
            }
            _ref3 = this.encodeBlock(block);
            for (_l = 0, _len = _ref3.length; _l < _len; _l++) {
              currentByte = _ref3[_l];
              bytes.push(currentByte);
            }
          }
        }
      }
      return this.encodeArray(bytes);
    };

    Compressor.prototype.decompress = function(string, map) {
      var block, blockPosition, bytes, bytesIndex, e, gapSize, remainder, x, y, z, _ref, _ref1, _results;
      try {
        bytes = this.decodeArray(string);
      } catch (_error) {
        e = _error;
        throw e;
      }
      bytesIndex = 0;
      blockPosition = 0;
      _results = [];
      while (bytesIndex < (bytes.length - 2)) {
        if (bytes[bytesIndex] === 0xFF) {
          gapSize = bytes[bytesIndex + 1] << 16 | bytes[bytesIndex + 2] << 8 | bytes[bytesIndex + 3];
          blockPosition += gapSize;
          bytesIndex += Compressor.BytesPerBlock;
        }
        try {
          block = this.decodeBlock(bytes.slice(bytesIndex, +(bytesIndex + Compressor.BytesPerBlock) + 1 || 9e9));
        } catch (_error) {
          e = _error;
          throw e;
        }
        _ref = this.quotientAndRemainder(blockPosition, map.size * map.size), x = _ref[0], remainder = _ref[1];
        _ref1 = this.quotientAndRemainder(remainder, map.size), y = _ref1[0], remainder = _ref1[1];
        z = remainder;
        map.setBlock(block, x, y, z);
        bytesIndex += Compressor.BytesPerBlock;
        _results.push(blockPosition++);
      }
      return _results;
    };

    Compressor.prototype.quotientAndRemainder = function(dividend, divisor) {
      var quotient, remainder;
      quotient = Math.floor(dividend / divisor);
      remainder = dividend % divisor;
      return [quotient, remainder];
    };

    Compressor.prototype.encodeArray = function(bytes) {
      var counter, currentByte, padding, string, tmp, _i, _len;
      string = new Array;
      counter = 0;
      tmp = 0;
      for (_i = 0, _len = bytes.length; _i < _len; _i++) {
        currentByte = bytes[_i];
        tmp = (tmp << 8) | currentByte;
        counter++;
        if (counter % 3 === 0) {
          string.push(this.encodeBytes(tmp));
          tmp = 0;
        }
      }
      if (counter % 3) {
        padding = 3 - counter % 3;
        tmp = tmp << (padding * 8);
        string.push(this.encodeBytes(tmp));
        if (padding === 1) {
          string.push('=');
        }
        if (padding === 2) {
          string.push('==');
        }
      }
      return string.join('');
    };

    Compressor.prototype.decodeArray = function(string) {
      var bytes, e, index, tmp;
      bytes = new Array;
      index = 0;
      while (index < string.length) {
        if (string[index] === '=') {
          index++;
          continue;
        }
        try {
          tmp = this.decodeBytes(string.slice(index, index + 4));
        } catch (_error) {
          e = _error;
          throw e;
        }
        bytes.push((tmp & 0xFF0000) >> 16);
        bytes.push((tmp & 0x00FF00) >> 8);
        bytes.push(tmp & 0x0000FF);
        index += 4;
      }
      return bytes;
    };

    Compressor.prototype.encodeBlock = function(block) {
      var bytes, lowRotation, lowType, midRotation, midType, topRotation, topType, _ref, _ref1, _ref2;
      bytes = new Array;
      _ref = block.getProperty('top'), topType = _ref[0], topRotation = _ref[1];
      _ref1 = block.getProperty('middle'), midType = _ref1[0], midRotation = _ref1[1];
      _ref2 = block.getProperty('low'), lowType = _ref2[0], lowRotation = _ref2[1];
      bytes.push((topRotation / 90) << 4 | (midRotation / 90) << 2 | (lowRotation / 90));
      bytes.push(Compressor.CompressionTable[topType] || 0x00);
      bytes.push(Compressor.CompressionTable[midType] || 0x00);
      bytes.push(Compressor.CompressionTable[lowType] || 0x00);
      return bytes;
    };

    Compressor.prototype.decodeBlock = function(bytes) {
      var code, lowRotation, lowType, midRotation, midType, properties, rotations, topRotation, topType, type, _ref;
      rotations = bytes[0];
      topRotation = 90 * ((rotations & 0x30) >> 4);
      midRotation = 90 * ((rotations & 0x0C) >> 2);
      lowRotation = 90 * (rotations & 0x03);
      _ref = Compressor.CompressionTable;
      for (type in _ref) {
        code = _ref[type];
        if (code === bytes[1]) {
          topType = type;
        }
        if (code === bytes[2]) {
          midType = type;
        }
        if (code === bytes[3]) {
          lowType = type;
        }
      }
      properties = {
        'top': [topType || null, topRotation],
        'middle': [midType || null, midRotation],
        'low': [lowType || null, lowRotation]
      };
      return new Block(properties);
    };

    Compressor.prototype.encodeBytes = function(bytes) {
      var e, result;
      try {
        return result = this.encodeBits((bytes & 0xFC0000) >> 18) + this.encodeBits((bytes & 0x03F000) >> 12) + this.encodeBits((bytes & 0x000FC0) >> 6) + this.encodeBits(bytes & 0x00003F);
      } catch (_error) {
        e = _error;
        throw e;
      }
    };

    Compressor.prototype.decodeBytes = function(string) {
      var e, result;
      if (string.length !== 4) {
        throw new Error("Illegal chunk size, was " + string.length);
      }
      try {
        result = (this.decodeBits(string[0]) << 18) | (this.decodeBits(string[1]) << 12) | (this.decodeBits(string[2]) << 6) | this.decodeBits(string[3]);
        return result;
      } catch (_error) {
        e = _error;
        throw e;
      }
    };

    Compressor.prototype.encodeBits = function(bits) {
      if ((0 <= bits && bits <= 25)) {
        return String.fromCharCode(65 + bits);
      }
      if ((26 <= bits && bits <= 51)) {
        return String.fromCharCode(97 + bits - 26);
      }
      if ((52 <= bits && bits <= 61)) {
        return String.fromCharCode(48 + bits - 52);
      }
      if (bits === 62) {
        return '-';
      }
      if (bits === 63) {
        return '_';
      }
      throw new Error("Invalid argument " + bits + " must be smaller than 0x3F (63)");
    };

    Compressor.prototype.decodeBits = function(character) {
      var charCode;
      charCode = character.charCodeAt(0);
      if ((65 <= charCode && charCode <= 90)) {
        return charCode - 65;
      }
      if ((97 <= charCode && charCode <= 122)) {
        return charCode - 97 + 26;
      }
      if ((48 <= charCode && charCode <= 57)) {
        return charCode - 48 + 52;
      }
      if (charCode === 45) {
        return 62;
      }
      if (charCode === 95) {
        return 63;
      }
      throw new Error("Invalid argument, char must be of [A-Za-z0-9-_], was " + character);
    };

    Compressor.CompressionTable = {
      'straight': 0x01,
      'curve': 0x02,
      'crossing': 0x03,
      'exchange': 0x04,
      'exchange-alt': 0x05,
      'dive': 0x06,
      'crossing-hole': 0x07,
      'drop-middle': 0x08,
      'drop-low': 0x09
    };

    return Compressor;

  })();

  Game = (function() {
    function Game(onload) {
      this.prepareRun = __bind(this.prepareRun, this);
      this.updateButton = __bind(this.updateButton, this);
      this.draggingUp = __bind(this.draggingUp, this);
      this.startDragWithBlocks = __bind(this.startDragWithBlocks, this);
      this.draggingMove = __bind(this.draggingMove, this);
      this.canvasDown = __bind(this.canvasDown, this);
      this.canvasMove = __bind(this.canvasMove, this);
      this.canvasUp = __bind(this.canvasUp, this);
      this.bodyUp = __bind(this.bodyUp, this);
      this.bodyMove = __bind(this.bodyMove, this);
      this.bodyDown = __bind(this.bodyDown, this);
      this.map = new Map(Settings.mapSize);
      if (window.state == null) {
        window.state = {};
      }
      state.type = 'normal';
      this.marbleRunning = false;
      this.mainCanvas = $(Settings.mainCanvasID);
      this.draggedCanvas = $(Settings.draggedCanvasID);
      this.selector = $(Settings.selectorID);
      this.marble = new Marble;
      this.animator = new Animator(this.map, this.marble);
      this.renderer = new Renderer(this.animator, this.map, this.marble, (function(_this) {
        return function() {
          var $body, animatorLoop, rotateEverything, selectorRotate;
          _this.mainCanvas.bind('mouseup', _this.canvasUp);
          _this.mainCanvas.bind('mousemove', _this.canvasMove);
          _this.mainCanvas.bind('mousedown', _this.canvasDown);
          _this.mainCanvas.bind('touchstart', _this.normalizeCoordinates(_this.canvasDown));
          _this.mainCanvas.bind('touchmove', _this.normalizeCoordinates(_this.canvasMove));
          _this.mainCanvas.bind('touchend', _this.normalizeCoordinates(_this.canvasUp));
          $body = $('body');
          $body.bind('mouseup', _this.bodyUp);
          $body.bind('mousemove', _this.bodyMove);
          $body.bind('mousedown', _this.bodyDown);
          $body.bind('touchstart', _this.normalizeCoordinates(_this.bodyDown));
          $body.bind('touchmove', _this.normalizeCoordinates(_this.bodyMove));
          $body.bind('touchend', _this.normalizeCoordinates(_this.bodyUp));
          rotateEverything = function(clockwise) {
            return function(event) {
              _this.selectBlock(null);
              _this.hideSelector();
              if (clockwise) {
                return _this.map.rotateCW();
              } else {
                return _this.map.rotateCCW();
              }
            };
          };
          $('#game .left').bind('mousedown', rotateEverything(false));
          $('#game .right').bind('mousedown', rotateEverything(true));
          selectorRotate = function(clockwise) {
            return function(event) {
              var block, blockOnTop, x, y, z, _ref;
              _ref = state.info.coordinates, x = _ref[0], y = _ref[1], z = _ref[2];
              block = _this.map.getBlock(x, y, z);
              if (z + 1 < _this.map.size) {
                blockOnTop = _this.map.getBlock(x, y, z + 1);
              }
              block.rotate(clockwise, true, true, false);
              if (blockOnTop) {
                blockOnTop.rotate(clockwise, false, false, true);
              }
              event.preventDefault();
              return false;
            };
          };
          _this.selector.children('.left').bind('mousedown', selectorRotate(false));
          _this.selector.children('.right').bind('mousedown', selectorRotate(true));
          _this.map.addListener('didChange', _this.updateButton);
          $('.run').bind('click', _this.prepareRun);
          _this.palette = new Palette(_this.renderer, _this.startDragWithBlocks);
          animatorLoop = function() {
            _this.animator.animate();
            return setTimeout(animatorLoop, 20);
          };
          setTimeout(animatorLoop, 20);
          return onload();
        };
      })(this));
    }

    Game.prototype.selectBlock = function(block) {
      if (this.selectedBlock) {
        this.selectedBlock.setSelected(false);
      }
      this.selectedBlock = block;
      if (this.selectedBlock) {
        return this.selectedBlock.setSelected(true);
      }
    };

    Game.prototype.displaySelector = function(x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      return this.selector.css({
        'display': 'block',
        'position': 'absolute',
        'top': this.mainCanvas.offset().top + y,
        'left': this.mainCanvas.offset().left + x
      });
    };

    Game.prototype.hideSelector = function() {
      return this.selector.css({
        'display': 'none'
      });
    };

    Game.prototype.bodyDown = function(event) {
      switch (state.type) {
        case 'normal':
          this.selectBlock(null);
          return this.hideSelector();
      }
    };

    Game.prototype.bodyMove = function(event) {
      switch (state.type) {
        case 'dragging':
          return this.draggingMove(event);
      }
    };

    Game.prototype.bodyUp = function(event) {
      switch (state.type) {
        case 'dragging':
          this.draggingUp(event);
      }
      return false;
    };

    Game.prototype.canvasUp = function(event) {
      var mouseX, mouseY, screenX, screenY, _ref;
      switch (state.type) {
        case 'dragging':
          this.draggingUp(event);
          break;
        case 'down':
          mouseX = event.pageX - this.mainCanvas.offset().left;
          mouseY = event.pageY - this.mainCanvas.offset().top;
          if (state.info.block === this.renderer.resolveScreenCoordinates(mouseX, mouseY).block) {
            this.selectBlock(state.info.block);
            _ref = this.renderer.renderingCoordinatesForBlock(state.info.block), screenX = _ref[0], screenY = _ref[1];
            this.displaySelector(screenX, screenY);
            state.type = 'normal';
          }
          break;
        case 'normal':
          this.selectBlock(null);
          this.hideSelector();
          break;
        default:
          if (DEBUG) {
            console.error("Illegal state", state.type);
          }
      }
      return false;
    };

    Game.prototype.canvasMove = function(event) {
      var mouseX, mouseY, side;
      mouseX = event.pageX - this.mainCanvas.offset().left;
      mouseY = event.pageY - this.mainCanvas.offset().top;
      switch (state.type) {
        case 'down':
          if (Math.abs(state.downX - mouseX) > Settings.draggingOffset || Math.abs(state.downY - mouseY) > Settings.draggingOffset) {
            this.startDrag(event);
          }
          break;
        case 'dragging':
          this.draggingMove(event);
          break;
        case 'normal':
          if (event.type !== 'touchmove') {
            side = this.renderer.sideAtScreenCoordinates(mouseX, mouseY);
            if (side && side !== 'floor') {
              this.mainCanvas.css('cursor', Settings.dragCursor);
            } else {
              this.mainCanvas.css('cursor', Settings.defaultCursor);
            }
          }
      }
      if (this.renderer.sideAtScreenCoordinates(mouseX, mouseY) !== null) {
        return event.preventDefault();
      }
    };

    Game.prototype.canvasDown = function(event) {
      var info, mouseX, mouseY;
      switch (state.type) {
        case 'normal':
          mouseX = event.pageX - this.mainCanvas.offset().left;
          mouseY = event.pageY - this.mainCanvas.offset().top;
          info = this.renderer.resolveScreenCoordinates(mouseX, mouseY);
          if (info.block) {
            state.type = 'down';
            state.downX = mouseX;
            state.downY = mouseY;
            state.info = info;
            event.preventDefault();
          }
      }
      return true;
    };

    Game.prototype.draggingMove = function(event) {
      var didRemoveBlocks, info, lowestBlock, mouseX, mouseY, offset, rotation, targetBlock, type, x, y, z, _ref, _ref1;
      didRemoveBlocks = false;
      this.map.blocksEach((function(_this) {
        return function(block) {
          var _ref;
          if (block.dragged) {
            (_ref = _this.map).removeBlock.apply(_ref, __slice.call(block.getCoordinates()).concat([true]));
            return didRemoveBlocks = true;
          }
        };
      })(this));
      mouseX = event.pageX - this.mainCanvas.offset().left;
      mouseY = event.pageY - this.mainCanvas.offset().top;
      info = this.renderer.resolveScreenCoordinates(mouseX, mouseY);
      _ref = info.coordinates || [0, 0, 0], x = _ref[0], y = _ref[1], z = _ref[2];
      targetBlock = this.map.getBlock(x, y, z);
      lowestBlock = state.stack && state.stack[0];
      $('body').css('cursor', Settings.draggingCursor);
      if (info.side === 'floor' || info.side === 'top' && this.map.heightAt(x, y) + state.stack.length < this.map.size + 1 && Block.canStack(targetBlock, lowestBlock)) {
        this.hideDraggedCanvas(event);
        if (lowestBlock) {
          if (info.side === 'top') {
            _ref1 = targetBlock.getProperty('top'), type = _ref1[0], rotation = _ref1[1];
            type = (type === 'crossing-hole') && 'crossing' || type;
            lowestBlock.setProperty('low', type, rotation, true);
          } else {
            lowestBlock.setProperty('low', null, 0, true);
          }
        }
        offset = info.side === 'top' ? 1 : 0;
        return this.map.setStack(state.stack, x, y, z + offset);
      } else {
        if (didRemoveBlocks) {
          this.map.forceUpdate();
        }
        return this.showDraggedCanvas(event);
      }
    };

    Game.prototype.startDrag = function(event) {
      var blocks, canvasX, canvasY, info, x, y, z, _ref, _ref1;
      _ref = state.info.coordinates, x = _ref[0], y = _ref[1], z = _ref[2];
      blocks = this.map.removeStack(x, y, z);
      _ref1 = this.renderer.renderingCoordinatesForBlock(blocks[blocks.length - 1]), canvasX = _ref1[0], canvasY = _ref1[1];
      info = {
        mouseOffsetX: state.downX - canvasX,
        mouseOffsetY: state.downY - canvasY
      };
      return this.startDragWithBlocks(blocks, info);
    };

    Game.prototype.startDragWithBlocks = function(blocks, info) {
      var block, _i, _len, _ref;
      this.selectBlock(null);
      this.hideSelector();
      state.stack = blocks;
      _ref = state.stack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        block.setDragged(true);
      }
      this.renderer.drawDraggedBlocks(state.stack);
      state.mouseOffsetX = info.mouseOffsetX;
      state.mouseOffsetY = info.mouseOffsetY;
      return state.type = 'dragging';
    };

    Game.prototype.hideDraggedCanvas = function(event) {
      return this.draggedCanvas.css('display', 'none');
    };

    Game.prototype.showDraggedCanvas = function(event) {
      var style;
      style = {
        'display': 'block',
        'position': 'absolute',
        'top': event.pageY - state.mouseOffsetY,
        'left': event.pageX - state.mouseOffsetX
      };
      return this.draggedCanvas.css(style);
    };

    Game.prototype.draggingUp = function(event) {
      state.stack = [];
      this.map.blocksEach((function(_this) {
        return function(block) {
          if (block.dragged) {
            return block.setDragged(false);
          }
        };
      })(this));
      this.map.forceUpdate();
      state.type = 'normal';
      $('body').css('cursor', Settings.defaultCursor);
      this.hideDraggedCanvas(event);
      return this.updateCanvasMargin();
    };

    Game.prototype.updateCanvasMargin = function() {
      var height;
      height = 0;
      this.map.blocksEach((function(_this) {
        return function(block) {
          var x, y, z, _ref;
          if (block.dragged) {
            return;
          }
          _ref = block.getCoordinates(), x = _ref[0], y = _ref[1], z = _ref[2];
          if (z > height) {
            return height = z;
          }
        };
      })(this));
      return this.mainCanvas.css({
        'margin-top': -50 + (-5 + height) * Settings.textureSizeHalf
      });
    };

    Game.prototype.normalizeCoordinates = function(handler) {
      return function(event) {
        if (event.originalEvent.touches && event.originalEvent.touches[0]) {
          event.pageX = event.originalEvent.touches[0].pageX;
          event.pageY = event.originalEvent.touches[0].pageY;
        }
        return handler(event);
      };
    };

    Game.prototype.updateButton = function() {
      var found;
      found = false;
      this.map.blocksEach((function(_this) {
        return function(block) {
          if (found) {
            return;
          }
          return found = block.getProperty('top')[0] === 'crossing-hole';
        };
      })(this));
      $('.run').toggleClass('inactive', !found);
      return $('.inserter').remove();
    };

    Game.prototype.prepareRun = function(event) {
      $('.inserter').remove();
      $('.popup').removeClass('visible');
      this.updateButton();
      if ($('.run').hasClass('inactive')) {
        $('#warning').addClass('visible');
        return $('#warning .dismiss').bind('click', (function(_this) {
          return function() {
            return $('#warning').removeClass('visible');
          };
        })(this));
      } else {
        return this.map.blocksEach((function(_this) {
          return function(block) {
            var $inserter, screenX, screenY, topRotation, topType, x, y, z, _ref, _ref1, _ref2;
            _ref = block.getProperty('top'), topType = _ref[0], topRotation = _ref[1];
            if (topType !== 'crossing-hole') {
              return;
            }
            _ref1 = block.getCoordinates(), x = _ref1[0], y = _ref1[1], z = _ref1[2];
            _ref2 = _this.renderer.renderingCoordinatesForBlock(block), screenX = _ref2[0], screenY = _ref2[1];
            $inserter = $('<div class="inserter" alt="Drop marble here!"></div>');
            $inserter.css({
              top: _this.mainCanvas.offset().top + screenY - Settings.textureSizeQuarter,
              left: _this.mainCanvas.offset().left + screenX + Settings.textureSizeQuarter
            });
            $inserter.bind('click', function() {
              x *= Settings.blockSize;
              y *= Settings.blockSize;
              z *= Settings.blockSize;
              x += Settings.blockSize / 2;
              y += Settings.blockSize / 2;
              z += Settings.blockSize * 3;
              _this.marble.setVelocities(0, 0, 0);
              _this.marble.setCoordinates(x, y, z);
              _this.marble.isOnTrack = false;
              return $('.inserter').remove();
            });
            return $('body').append($inserter);
          };
        })(this));
      }
    };

    return Game;

  })();

  Palette = (function() {
    function Palette(renderer, startDragCallback) {
      var $image, $palette, block, callback, canvas, context, description, textureStore, type, _ref;
      this.renderer = renderer;
      this.startDragCallback = startDragCallback != null ? startDragCallback : function() {};
      $palette = $(Settings.paletteID);
      _ref = Block.Types;
      for (type in _ref) {
        description = _ref[type];
        block = Block.ofType(type);
        block.setOpacity(0.4);
        canvas = document.createElement('canvas');
        canvas.width = Settings.textureSize;
        canvas.height = Settings.textureSize;
        context = canvas.getContext('2d');
        this.renderer.drawBlock(context, block);
        this.textureStore = this.renderer.getTextureStore();
        $image = $('<img>');
        $image.data('type', type);
        $image.attr('src', canvas.toDataURL());
        $palette.append($image);
        callback = this.startDragCallback;
        $image.bind('mousedown', function(event) {
          var info;
          info = {
            mouseOffsetX: event.pageX - $(this).offset().left,
            mouseOffsetY: event.pageY - $(this).offset().top
          };
          block = Block.ofType($(this).data('type'));
          callback([block], info);
          return event.preventDefault();
        });
        $image.bind('touchstart', function(event) {
          var info;
          if (event.originalEvent.touches.length) {
            info = {
              mouseOffsetX: event.originalEvent.touches[0].pageX - $(this).offset().left,
              mouseOffsetY: event.originalEvent.touches[0].pageY - $(this).offset().top
            };
            block = Block.ofType($(this).data('type'));
            callback([block], info);
            return event.preventDefault();
          }
        });
        textureStore = this.textureStore;
        $image.bind('mousemove', function(event) {
          var pixel, x, y;
          if (state.type === 'normal') {
            x = event.pageX - $(this).offset().left;
            y = event.pageY - $(this).offset().top;
            pixel = textureStore.getTexture('basic', 'hitbox').getContext('2d').getImageData(x, y, 1, 1);
            if (pixel.data[3] > 0) {
              $('body').css('cursor', Settings.dragCursor);
            } else {
              $('body').css('cursor', Settings.defaultCursor);
            }
            return false;
          }
        });
      }
    }

    return Palette;

  })();

  $(document).ready(function() {
    return this.game = new Game((function(_this) {
      return function() {
        var compressor, e, updateNetworks;
        if (window.location.hash.length > 1) {
          try {
            compressor = new Compressor;
            compressor.decompress(window.location.hash.slice(1), _this.game.map);
            _this.game.updateCanvasMargin();
          } catch (_error) {
            e = _error;
            if (DEBUG) {
              console.error("Could not parse map correctly: " + e);
            }
          }
        }
        _this.game.updateButton();
        $('#share input').focus(function() {
          return this.select();
        });
        $('.network.button').bind('click', function(event) {
          var url;
          event.preventDefault();
          url = $(this).attr('href');
          return window.open(url, 'popup', 'location=1,width=600,height=290,toolbar=no,scrollbars=no');
        });
        updateNetworks = function(url) {
          var escaped;
          escaped = encodeURI(url).replace('#', '%23');
          $('.facebook').attr({
            'href': "http://facebook.com/sharer.php?u=" + escaped
          });
          return $('.twitter').attr({
            'href': "http://twitter.com/share?text=I've+built+a+marble+run+with+%23marbleous,+check+it+out&url=" + escaped
          });
        };
        return $('.button.share').bind('click', function() {
          var string, url;
          $('.popup').removeClass('visible');
          compressor = new Compressor;
          string = compressor.compress(_this.game.map);
          url = 'http://marbleo.us/#' + string;
          window.location.replace('#' + string);
          $('#share input').val(url);
          updateNetworks(url);
          $('#share').addClass('visible');
          $('#share .dismiss').bind('click', function() {
            return $('#share').removeClass('visible');
          });
          return $.ajax({
            'url': 'http://api.bitly.com/v3/shorten',
            'data': {
              'format': 'json',
              'login': 'robertboehnke',
              'apiKey': BITLY_API_KEY,
              'longUrl': url
            },
            'success': function(result, status) {
              if (result['status_code'] === 200) {
                $('#share input').val(result['data']['url']);
                return updateNetworks(result['data']['url']);
              }
            }
          });
        });
      };
    })(this));
  });

  VisibilityLayer = (function(_super) {
    __extends(VisibilityLayer, _super);

    function VisibilityLayer(map, renderer, marble) {
      this.map = map;
      this.renderer = renderer;
      this.marble = marble;
      VisibilityLayer.__super__.constructor.call(this, this.map, this.renderer);
      this.cache = {};
    }

    VisibilityLayer.prototype.redraw = function() {
      var mScreenX, mScreenY, mX, mY, mZ, r, _ref, _ref1;
      this.clear();
      _ref = this.marble.getCoordinates(), mX = _ref[0], mY = _ref[1], mZ = _ref[2];
      _ref1 = this.renderer.renderingCoordinatesForMarble(this.marble), mScreenX = _ref1[0], mScreenY = _ref1[1];
      r = this.marble.radius;
      return this.map.coordinatesEach((function(_this) {
        return function(x, y, z) {
          var block, screenX, screenY, _ref2;
          if (x * Settings.blockSize >= mX + _this.marble.radius || (y + 1) * Settings.blockSize <= mY - _this.marble.radius || (z + 1) * Settings.blockSize <= mZ - _this.marble.radius) {
            return;
          }
          if (!(block = _this.map.getBlock(x, y, z))) {
            return;
          }
          _ref2 = _this.renderer.renderingCoordinatesForBlock(block), screenX = _ref2[0], screenY = _ref2[1];
          if (!(screenX <= mScreenX + r && mScreenX - r < mScreenX + Settings.textureSize && screenY <= mScreenY + r && mScreenY - r < mScreenY + Settings.textureSize)) {
            return;
          }
          if ((x + 1) * Settings.blockSize < mX - r || y * Settings.blockSize > mY + r || z * Settings.blockSize > mZ + r) {
            return _this.drawBlock(_this.context, block, screenX, screenY);
          } else {
            return _this.drawTopMask(_this.context, block, screenX, screenY);
          }
        };
      })(this));
    };

    VisibilityLayer.prototype.drawBlock = function(context, block, x, y) {
      var buffer, cacheKey, cached, cutouts, hitbox, lowRotation, lowType, midRotation, midType, topRotation, topType, type, _ref, _ref1, _ref2;
      cacheKey = block.toString();
      if (!(cached = this.cache[cacheKey])) {
        _ref = block.getProperty('top'), topType = _ref[0], topRotation = _ref[1];
        _ref1 = block.getProperty('middle'), midType = _ref1[0], midRotation = _ref1[1];
        _ref2 = block.getProperty('low'), lowType = _ref2[0], lowRotation = _ref2[1];
        this.cache[cacheKey] = cached = document.createElement('canvas');
        cached.height = cached.width = Settings.textureSize;
        buffer = cached.getContext("2d");
        hitbox = this.getTexture('basic', 'hitbox');
        buffer.globalCompositeOperation = 'source-over';
        buffer.drawImage(hitbox, 0, 0);
        type = topType === 'crossing-hole' ? 'crossing' : topType;
        cutouts = this.getTexture('cutouts-top', type, topRotation);
        buffer.globalCompositeOperation = 'destination-out';
        if (cutouts) {
          buffer.drawImage(cutouts, 0, 0);
        }
        cutouts = this.getTexture('cutouts-bottom', lowType, lowRotation);
        if (cutouts) {
          buffer.drawImage(cutouts, 0, 0);
        }
      }
      context.globalCompositeOperation = 'source-over';
      return context.drawImage(cached, x, y);
    };

    VisibilityLayer.prototype.drawTopMask = function(context, block, x, y) {
      var cutoutsBottom, cutoutsTop, hitbox, lowHoleEast, lowHoleSouth, lowHoles, lowRotation, lowType, midHoleEast, midHoleSouth, midHoles, midRotation, midType, pos, topLayer, topRotation, topType, type, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
      _ref = block.getProperty('top'), topType = _ref[0], topRotation = _ref[1];
      _ref1 = block.getProperty('middle'), midType = _ref1[0], midRotation = _ref1[1];
      _ref2 = block.getProperty('low'), lowType = _ref2[0], lowRotation = _ref2[1];
      context.globalCompositeOperation = 'source-over';
      hitbox = this.getTexture('basic', 'hitbox');
      context.drawImage(hitbox, x, y);
      context.globalCompositeOperation = 'destination-out';
      topLayer = this.getTexture('top', topType, topRotation);
      if (topLayer) {
        context.drawImage(topLayer, x, y);
      }
      type = topType === 'crossing-hole' ? 'crossing' : topType;
      cutoutsTop = this.getTexture('cutouts-top', type, topRotation);
      if (cutoutsTop) {
        context.drawImage(cutoutsTop, x, y);
      }
      cutoutsBottom = this.getTexture('cutouts-bottom', lowType, lowRotation);
      if (cutoutsBottom) {
        context.drawImage(cutoutsBottom, x, y);
      }
      if (midHoles = VisibilityLayer.MidHoles[midType]) {
        for (_i = 0, _len = midHoles.length; _i < _len; _i++) {
          pos = midHoles[_i];
          if ((pos + midRotation) % 360 === 0) {
            midHoleSouth = this.getTexture('basic', 'hole-middle', 0);
            context.drawImage(midHoleSouth, x, y);
          }
          if ((pos + midRotation) % 360 === 90) {
            midHoleEast = this.getTexture('basic', 'hole-middle', 90);
            context.drawImage(midHoleEast, x, y);
          }
        }
      }
      if (lowHoles = VisibilityLayer.LowHoles[midType]) {
        _results = [];
        for (_j = 0, _len1 = lowHoles.length; _j < _len1; _j++) {
          pos = lowHoles[_j];
          if ((pos + midRotation) % 360 === 0) {
            lowHoleSouth = this.getTexture('basic', 'hole-low', 0);
            context.drawImage(lowHoleSouth, x, y);
          }
          if ((pos + midRotation) % 360 === 90) {
            lowHoleEast = this.getTexture('basic', 'hole-low', 90);
            _results.push(context.drawImage(lowHoleEast, x, y));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    VisibilityLayer.MidHoles = {
      'crossing': [0, 90, 180, 270],
      'curve': [0, 90],
      'straight': [0, 180],
      'dive': [0],
      'drop-middle': [0],
      'exchange': [0],
      'exchange-alt': [90]
    };

    VisibilityLayer.LowHoles = {
      'dive': [180],
      'drop-low': [0],
      'exchange': [90],
      'exchange-alt': [0]
    };

    return VisibilityLayer;

  })(Layer);

}).call(this);
